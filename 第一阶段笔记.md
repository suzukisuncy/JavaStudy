# FOUNDATION01

### Java开发环境以及搭建

#### 一、Java

#### Java是一款编程语言 ,编程语言是人类与计算机沟通的桥梁,Java只是编程语言中的一种。

##### Java的编译运行过程：

- ##### 编译期:  .java(源文件)  ------经过编译 ----生成后缀.class字节码文件

- ##### 运行期: jvm负责加载并运行.class字节码文件

  > ##### Java语言特点:一次编译.到处执行----扩平台特性

#### 名词解释

- ##### JVM:java虚拟机,负责加载并运行.class字节码文件

- ##### JRE:java运行环境,包含JVM,还包含了运行Java程序所需要工具

  ##### 	     JRE =  JVM + java类库小工具.

- ##### JDK:java开发工具包,包含JRE ,包含了java编译运行等命令

  #####  	  JDK =  JRE +  编译运行等命令

  - ##### 如果电脑只想运行JAVA程序,只需要给电脑安装JRE.

  - ##### 如果电脑想要开发JAVA程序,电脑必须要安装JDK.

    #### JDK理解为汽油, 编译器工具理解为汽车          ------更好的开发JAVA程序!

#### 二 编译器工具

##### 车(自动挡(IDEA)/手动挡(Eclipse))

##### IDEA的版本  -------->  社区版(免费)    终极版(收费/且要用的)

##### 开源:对用户开放    IDEA(开源)     Java(开放源代码)

---



#### JAVA的开发步骤

1. ##### 新建一个项目     -------------选好楼盘项目

2. ##### 新建一个包        --------------楼+单元

3. ##### 新建一个类       ---------------房子

##### 注释：对代码的解释,注释给人看的,所有注释不会被编译.

##### Java中的注释分为三种：

- ##### 单行注释:   // 写上解释性内容

- ##### 多行注释：/* 写上解释性内容   */

- ##### 文档注释:  /** 写上解释性内容  */

```java
package day01; // 包  包名 day01     ------- 楼 + 单元

public class HelloWorld {//类  类名HelloWorld  --------房子
    //main 功能 ： 程序的主入口  运行程序必须要有main功能！
    //main 快捷键：快速生成main功能    在类中空白区域英文状态下 敲 main 有提示回车即可！
    public static void main(String[] args) { //大门 代码需要运行则放在大门里
        /**程序的执行：顺序执行
         * 1, Java是严格区分大小写！
         * 2, 写代码的期间始终保持输入法是英文状态下
         * 3,一行代码结尾加英文分号 ;
         */
        //打印功能：主要负责输出打印的信息(文字,数字,符号.....)
        //sout快捷键：快速生成打印语句
        //注意：文字,字母,符号等特殊内容若须打印,需要放在双引号里面才可以
        //数值的数据,都可以直接放在小括号中进行打印
        System.out.println("hello java!");//双引号中的内容 所见即所得！
    }//程序执行到main的结束花括号 则程序退出
}

```

##### 大家以后学习任何的技术,至少弄懂3个点： 1.这个技术干啥用的？  2.为什么要写这个技术  3.学完怎么用?在哪用？

------

### 变量

##### 早期的计算机  --------------计算 (数据的运算)

##### 现在的计算机  --------------计算 (数字,文字,图片,音频,视频) 

##### 计算机不论是早期还是现在,处理的始终是数据,数据而是需要变量来存储。

##### 变量就是存储数据的！

1. ##### 变量的声明   (去银行开账户)

   ```java
   int a;//声明了一个存储整数的变量  变量名为a
   int b,c,d;//声明了三个存整数的变量 变量名分别为 b c d
   //int a;编译错误：重复声明变量 a
   ```

2. ##### 变量的初始化 (为已开账户存钱)

   > 声明+初始化：指的是声明变量的同时为账户存钱
   >
   > = : 在程序中表示赋值号  赋值的过程，从右向左赋值

   ```java
   int e = 300;//声明了一个存储整数的变量 名为e  并为e存储了300这个整数
   int f; //声明一个存储整数的变量 名为 f
   f = 300;//为f这个变量存储300这个数据
   f = 500;//变量第二次赋值称为改变。
   System.out.println(f);
   ```

3. ##### 变量的使用 (使用账户里的钱)

   ```java
   int b = 5;
   int c = b + 10;
   System.out.println("c");//c
   //System.out.println(C);编译错误：使用未声明的变量 C
   System.out.println(c);//15
   c = 25;              //使用变量时,以变量当前使用前最后一次赋值为准
   System.out.println(c);
   ```

   ##### 测试:

   ```java
   package day02;
   
   /**
    * 变量的使用演示类
    */
   public class VarDemo { //类 ---- 房子
       public static void main(String[] args) { // 大门 ---程序的主入口
           //变量的声明
           int a;//声明了一个存储整数的变量  变量名为a
   //        int b,c,d;//声明了三个存整数的变量 变量名分别为 b c d
           //int a;编译错误：重复声明变量 a
           //变量的初始化
           int e = 300;//声明了一个存储整数的变量 名为e  并为e存储了300这个整数
           int f; //声明一个存储整数的变量 名为 f
           f = 300;//为f这个变量存储300这个数据
           f = 500;//变量第二次赋值称为改变。
           System.out.println(f);
           //变量的使用
           int b = 5;
           int c = b + 10;
           System.out.println("c");//c
           //System.out.println(C);编译错误：使用未声明的变量 C
           System.out.println(c);//15
           c = 25;              //使用变量时,以变量当前使用前最后一次赋值为准
           System.out.println(c);
   
           //整理代码的格式快捷键:   ctrl +  alt +  L
           //注释的快捷 :  ctrl  + /
           //撤销快捷: ctrl + z
           //复制 粘贴 : ctrl + C     ctrl+V
           //快速复制当前选中行:ctrl +D
       }
   }
   
   ```

4. ##### 变量的命名规范

   - ##### 变量名允许包含数字,字母,_和$,且不能以数字开头

   - ##### 变量名不能有关键字 (指的是Java中已使用的名字)

   - ##### 变量名要求见名知意

   - ##### 多个单词之间 变量命名遵循小驼峰命名法   首单词字母小写,第二单词首字母大写,以此类推....

```java
   //变量的命名规范  变量名允许包含数字,字母,_和$,且不能以数字开头
        int a1_$;
//        int 1a_$;不能以数字开头
        int _abc;	
//        int void; 变量名不能跟关键字一样
//        int int;

//        int 年龄; 不建议
//          int nianling; 不建议
        int age;//建议英文单词的见名知意
        int myAge;//多个单词之间 变量命名遵循小驼峰命名法
        
        //类的命名规范 大驼峰   例如: VarDemo
        //包的命名规范 纯小写
```

#### 数据类型

> ##### 作用：决定了变量可以存储什么类型的数据以及多大范围的数据.

##### 数据类型分为两类：基本数据类型(重点)   和   引用数据类型(面向对象讲)

##### 基本数据类型8种：byte , short , int , long , float ,double ,char , boolean

##### 常用的数据类型：  int ,  long , double , char ，boolean

----------

##### gb 吉字节

##### 1gb  =  1024 mb

##### mb兆字节

##### 1mb  = 1024kb

##### kb千字节

##### 1kb  =  1024 b

##### b  字节

##### 1b   =  8bit(位)

----

#### 整数类型

- ##### int

  - ##### 在内存中占用4个字节,存储的范围  -21亿多  ~   21亿

  1. ##### 整数的直接量,默认是int类型,直接量注意是不可以超过当前变量类型所容纳的范围,否则就编译错误.

  2. ##### 整数运算,结果是不会保留小数位(截断删除小数位)

  3. ##### 整数运算,若运算结果超过当前类型所容纳的范围,则会溢出(注意,溢出不是错误!)但是需要避免,溢出的数据没有意义.

```java
         //100 就是整数直接量 默认就是int类型
        int a = 100;
        //int存储范围 最大值：2147483647   最小值:   -2147483648
//        int b = 2147483648;
        int c = 5;
        int d = 2;
        System.out.println( c / d );//2

        int e = 2147483647;
        int f = e + 3;
        System.out.println(f);//溢出的数据...
        /**
         *  +1  --------------(-2147483648)
         *  +1+1--------------(-2147483647)
         *  +2+1--------------(-2147483646)
         */
```

```java
变量占用多大内存,取决的是变量的数据类型而非装载的数据！
int a = 5;
int b = 2147483647;
```

- ##### long

  - ##### long类型在内存中占用8个字节,可以存存储-900万万亿~900万万亿.

1. ##### 长整数类型直接量需要在后缀加L,明确表示该直接量是long类型

2. ##### 长整数类型在进行运算时,建议在第一个数据后缀L,那么能确保至少运算结果是long类型.

```java
  //long 类型的直接量 后缀加L

        long a = 2147483648000L;
                //10亿x2 是int结果没超过int所容纳的范围
        long b = 1000000000 * 2 * 10L;
        System.out.println(b);//200亿
               //10亿x3 是int类型结果超过int所容纳的范围 就溢出了,再运算也是不准确的数据
        long c = 1000000000 * 3 * 10L;
        System.out.println(c);//溢出的数据

        long d = 1000000000L * 3 * 10;//long类型在进行运算时,建议在第一个数据后缀L  
        System.out.println(d);//300亿
```

#### 小数类型:

- ##### double

  - ##### 在内存中占用8个字节,可以存很大很大的数据

  1. ##### 浮点型数据(小数),直接量默认就是double类型,也可以直接量后缀D明确表示该直接量类型.

  2. ##### double类型的数据在进行运算时,可以存在误差!

     ```java
     		 //double类型的演示
             // 3.14 ---小数直接量 默认就是double类型
             double a = 3.14;
     
             double b = 3.0;
             double c = 2.9;
             System.out.println( b - c );//结果存在误差  0.10000000000000009
     
             double e = 6.0;
             double f = 4.9;
             System.out.println(e - f);//结果存在误差  1.0999999999999996
     
             double g = 6.0;
             double h = 1.9;
             System.out.println(g - h);//结果存在误差  4.1
     
             //BigDecimal 类型可以解决不精确的问题   了解即可 不需要写
             BigDecimal a1 = BigDecimal.valueOf(3.0);
             BigDecimal b1 = BigDecimal.valueOf(2.9);
             System.out.println(a1.subtract(b1));//0.1
     ```

- #### char

  - ##### 占用内存2个字节,表示字符的意思。

  - ##### 什么是字符：键盘上的字母,数字,汉字,特殊符号等等.....

  ##### Unicode:万国码,统一字符码,Unicode中划分了很多个子集, char类型采用的是Unicode中最常用的子集(ASCII)码表

  1. ##### 一个字符对应一个码,本质上用的是字符,实际处理的还是码  (0  ~ 66535)

  2. ##### 字符类型的直接量,只能用单引号来存储,且只能存储一个字符,至少一个字符.

  3. ##### Java提供了特殊符号,如果想存储,需要转义(将特殊含义转换为普通含义). 转义符:    \

```java
  //char 类型
        char temp = 'A';
        System.out.println(temp);//打印显示字符
        System.out.println((int)temp);//可以将字符转换成对应的码
        char t1 = '\'';
        System.out.println(t1);
        char t2 = '\\';
        System.out.println(t2);
        char t3 = '男';
        System.out.println(t3);
```

- ##### boolean类型

  - ##### 在内存中占用1个字节,只能存一个 要么是true(成立)  要么是false（false）

  ```java
  //        boolean a1 = 1 > 1; a1变量存储的是 1是否 > 1 的判断结果  
          boolean a = true;//成立
          boolean b = false;//不成立
          System.out.println(a);//true
          System.out.println(b);//false
  ```

##### 基本数据类型之间转换

- ##### 基本数据类型从小到大： byte ---- short  ----int  ----long ----- float ----double

1. ##### 自动类型转换(隐式转换):将小的类型 赋值给 大类型的过程.

2. ##### 强制类型转换(显示转换):将大的类型 赋值给 小类型的过程.

```java
  /**
         * 1.自动类型转换(隐式转换):将小的类型 赋值给 大类型的过程.
         *          int a = 100;//没有发生类型转换
         *         long b = a;//发生自动类型转换
         *         double c = b;//发生自动类型转换
         *
         *         long a1 = 2000000000L;//20亿
         *         int b1 = (int)a1;//使用强转语法：在需要强转的变量前加小括号 ----(写上强转类型即可)
         *         System.out.println(b1);//20亿
         * 2.强制类型转换(显示转换):将大的类型 赋值给 小类型的过程.
         *          long a2 = 3000000000L;//30亿
         *         int b2 = (int)a2;//使用强转语法：在需要强转的变量前加小括号 ----(写上强转类型即可)
         *         System.out.println(b2);//溢出的数据  因为30亿超过int类型的存储范围.
         *
         *         double c1 = 3.14;
         *         int d = (int)c1; //小数强转为整数,结果是不会保留小数位
         *         System.out.println(d);//3
         *         System.out.println(c1);//3.14
         *         c1 = d;//整数赋值给小数类型,则会有小数位.
         *         System.out.println(c1);//3.0
         */

```

##### 规则：

1. ##### 整数直接量是可以直接赋值给byte,short,char类型的,但是直接量不能超过当前类型所容纳的范围.

2. ##### byte,short,char类型如果运算,系统会自动将运算结果转换为int类型.

3. ##### 小类型与大类型在进行运算时,运算结果会自动上升为大类型。

```java
  /**运算规则：
         * 整数直接量是可以直接赋值给byte,short,char类型的,但是直接量不能超过当前类型所容纳的范围.
         * byte,short,char类型如果运算,系统会自动将运算结果转换为int类型.
         * 小类型与大类型在进行运算时,运算结果会自动上升为大类型。
         */
        //byte范围: -128 ~ 127
        byte a = 127;
        //char码范围：0 ~ 65535
        char b = 65535;
        System.out.println(b);

        byte b1 = 120;
        byte b2 = 7;
        byte result = (byte) (b1 + b2);
        System.out.println(result);

        char c1 = 'A';//A的码是65
        char c2 = 'A';
        char r2 = (char)(c1 + c2);//码+码 结果强转成对应的 字符
        System.out.println(r2);

        int i1 = 100;
        long l2 = 200L;
        long r3 = i1 + l2;// int + long ,long大 所以运算结果为long类型
        System.out.println(r3);//300
```

#### 运算符

- ##### 数学运算符

  - ##### 符号：  +    -    *    /           取余号(%)

    ```java
    package day03;
    
    /**
     * 数学运算符 and 自增自减运算符 的使用演示类
     */
    public class OperationDemo01 {
        public static void main(String[] args) {
            /** 数学运算符
             *         int a = 10;
             *         int b = 5;
             *         int c = a + b;//常规写法
             *         System.out.println(c);//15
             *         //测试写法
             *         System.out.println(a - b);//5
             *         System.out.println(a * b);//50
             *         System.out.println(a / b);//2
             *         //取余 取得是余数  例如： a % b  则表示 取 a / b 的余数
             *         System.out.println(a % b);//0
             *         //取余的使用场景： 1.想判断一个数 是否被 另一个数 整除 2.想判断一个数是否是偶数..
             *         //快速取余运算,取余操作时,若左边的数据 小于右边数据的  余数还是左边的数据
             *         System.out.println(1 % 3);//1
             *         System.out.println(2 % 3);//2
             *         System.out.println(3 % 3);//0
             */
        }
    }
    ```

- ##### 自增自减运算符

  > ##### 自增自减运算符操作的是变量

  - ##### 自增：在变量自身基础上增加1,符号： ++

  - ##### 自减：在变量自身基础上减少1,符号： --

    - ##### 单独(元)运算：符号在前后都一样,执行该行后都会完成对应的自增或自减的操作。

    - ##### 参与运算(赋值号也是运算)：符号在前在后不一样

      - ##### 符号在前,先去执行符号对应的自增或自减操作,然后再参与其它运算.

      - ##### 符号在后,先去参与其它运算,最后再执行符号对应的自增或自减操作.

      ```java
        /** 自增自减运算符:
               * 单独(元)运算：符号在前后都一样,执行该行后都会完成对应的自增或自减的操作。
               *         int a = 5;
               *         ++a;//a自身基础增加1
               *         System.out.println(a);//6
               *         --a;//a自身基础减少1
               *         System.out.println(a);//5
               */
              /** 参与运算(赋值号也是运算)：符号在前在后不一样
               * 符号在前,先去执行符号对应的自增或自减操作,然后再参与其它运算.
               * 符号在后,先去参与其它运算,最后再执行符号对应的自增或自减操作.
               */
      //         int a = 5;
      //         int b = 5;
      //         int c = a++;
      //         int d = ++b;
      //        System.out.println(a);//6
      //        System.out.println(b);//6
      //        System.out.println(c);//5
      //        System.out.println(d);//6
      
      //        int a = 5;
      //        int b = 5;
      //        int c = a--;
      //        int d = --b;
      //        System.out.println(a);
      //        System.out.println(b);
      //        System.out.println(c);
      //        System.out.println(d);
      //        int a = 5;
      //        System.out.println(a++);//5
      //        System.out.println(a);//6
      //
      //        System.out.println(--a);//5
      //        System.out.println(a);//5
      
              /** 面试题：考察的是自增或自减的底层的运算规则
               *
               */
              int a = 1;
              /**符号在后:
               *  (1) 先将变量中内容赋值给 临时变量  temp = a
               *  (2) 在进行变量的自增             a = a + 1;
               *  (3) 将临时变量中的内容赋值给a      a = temp;
               */
              a = a++;
              System.out.println(a);//1
      
      
              int b = 1;
              /**符号在前:
               *  (1) 在进行变量的自增             b = b + 1;
               *  (2) 先将变量中内容赋值给 临时变量  temp = b
               *  (3) 将临时变量中的内容赋值给a      b = temp;
               */
              b  = ++b;
              System.out.println(b);//2
      ```

- ##### 关系运算符

  > 关系运算符指的是：大于,小于,大于等于,小于等于,等于,不等于
  >
  > 关系运算符的结果,一定是boolean类型的值！

  - ##### 符号：大于(>)  小于(<)    大于等于(>=),小于等于(<=), 等于(==),不等于(!=)

  ```java
  package day03;
  
  /**
   * 关系运算符
   * 逻辑运算符
   */
  public class OperationDemo02 {
      public static void main(String[] args) {
          /**关系运算符：大于,小于,大于等于,小于等于,等于,不等于
           *         int a = 50;
           *         int b = 40;
           *         boolean c = a > b;//常规写法
           *         System.out.println(c);//true
           *         System.out.println(a <= b);//false
           *         System.out.println(10 >= 10);//true
           *         System.out.println(5 != 4);//true
           *         System.out.println(2 == 2);//true
           *         System.out.println(100 != 100);//false
           */
      }
  }
  ```

- ##### 逻辑运算符

  > 逻辑运算符结果一定是boolean类型的结果.

  ##### Java中逻辑运算符分三种

  - ##### 与(并且),符号就是&&：

    ```java
    逻辑与(并且)  现象:在逻辑与的关系中,两个或多个条件,只要有一个条件不满足,其结果一定不成立.
        	     一假 俱 假 (见 false 即 false)
        
    能毕业吗?
        	条件一：课程学完了吗?   true    false    false   true
              并且
            条件二: 考试及格了吗?   false   true     false   true
                
                		  结果:   false   false    false   true
        
    ```

  - ##### 或(或者),符号就是||:

    ```java
    逻辑或(或者) 现象:在逻辑或的关系中,两个或多个条件,只要有一个条件满足,其结果一定满足.
                一 真 俱 真 (见true 即 true)
    能结账吗?
            条件一:微信有钱吗?  false   true   true   false
                或者
            条件二:带现金了吗?  true    false  true   false
                    
                       结果:  true    true   true   false
    ```

  - ##### 非(取反),符号就是!  :

    ```java
    逻辑非(取反)                结果:
        	  true----- !true ----false   非真即假
              false---- !false ---true    非假即真
    ```

    ```java
       /**逻辑运算符: 逻辑与(&&)   逻辑或(||)   逻辑非(!)
             * 逻辑与(&&),见false 即 false
             * 逻辑或(||),见true  即 true
    			逻辑非(!), 非真即假   非假即真
             */
    //        int a = 5;
    //        int b = 10;
    //        int c = 5;
    //        boolean result = a > b && b > c;// false && true ----- false
    //        System.out.println(result);//false
    //        System.out.println(a > b || b > c);// false || true -----true
    //        System.out.println(a == ++c && c > 5);//false && true ----- false
    //        System.out.println(c > a && b == 10);//true && true   -----true
    //        System.out.println(!(c == 6) && a == 5);//false && true ----- false
    
            //判断年份是否是闰年?
            /**  year 表示年份
             *     是闰年条件：
             *              条件1：年份能被4整除 并且 年份不能被100整除
             *              或者
             *              条件2: 年份能被400整除
             */
            //Scanner  扫描器功能: 提供了可以在控制台接收键入的数据(整数,小数....)
            Scanner s = new Scanner(System.in);//创建一个扫描器
            System.out.println("请输入要判断的年份,回车即可！");
            int year = s.nextInt();//nextInt() 用来接收控制台中键入的整数的数据
            boolean r1 = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
            System.out.println(r1);
    ```

  ##### 短路逻辑：

  - ##### 短路与现象：两个或多个条件,若前面的条件有不成立的,则立刻返回不成立结果.

  - ##### 短路或现象：两个或多个条件,若前面的条件成立,则立刻返回成立结果.

  ```java
   /** 短路现象：
           * 短路与现象：两个或多个条件,若前面的条件有不成立的,则立刻返回不成立结果.
           * 短路或现象：两个或多个条件,若前面的条件成立,则立刻返回成立结果.
           *         int a = 5;
           *         int b = 20;
           *         System.out.println(a > b && ++b > a);//false    发生了短路与
           *         System.out.println(b);//20
           *
           *         System.out.println(a < b && ++b >a);//true      未发生短路
           *         System.out.println(b);//21
           *
           *         System.out.println(++a < b || ++b >= 21);//true  发生了短路或
           *         System.out.println(b);//21
           */
  ```

- ##### 扩展赋值运算符

  - ##### 可以在变量自身基础进行运算,并将运算结果赋值给自身.

  - ##### 符号： +=    -=     *=  /=     %=

    ```java
     /** 扩展赋值运算符: 可以在变量自身基础进行运算,并将运算结果赋值给自身
             *   int a = 10;
             *         a += 10; // 等价于:  a = a + 10;
             *         System.out.println(a);//20
             *
             *         a -= 10; // 等价于:  a = a - 10;
             *         System.out.println(a);//10
             *
             *         a *= 2;//   等价于:  a = a * 2;
             *         System.out.println(a);//20
             *
             *         a /= 5; //  等价于:  a = a / 5;
             *         System.out.println(a);//4
             *
             *         a %= 2; //  等价于:  a = a % 2;
             *         System.out.println(a);//0
             *
             *         //面试题：
             *         /**
             *          *         byte b = 5;
             *          *         b = b + 5;//编译错误: byte运算 结果是int  赋值给b 则报错误
             *          *         System.out.println(b);
             *
            byte b = 5;
            b += 5;// 实际上 做了强转 -->  b = (byte)(b + 5);
            System.out.println(b);//10
             */
    ```

- ##### 三元表达式

  ##### 格式 :   判断的条件 ?  值1 :  值2

  > 判断的条件若成立,则将值1的数据返回
  >
  > ​					若不成立,则将值2的数据返回

  ```java
    /**格式 :   判断的条件 ?  值1 :  值2
           * 判断的条件若成立,则将值1的数据返回
           * 判断的条件若不成立,则将值2的数据返回
           */
          int a = 10;
          int b = 20;
          //需求:求a和b之间最大值。
          int max = a > b ? a : b;
          System.out.println(max);//20
          //值1 和 值2 类型要匹配或可以自动转换,否则编译错误
          //需求：判断c是否是偶数 用三元表达式 返回 true  或 false 表示是与不是.
          int c  = 8;
          boolean r = c % 2 == 0 ? true:false;
          System.out.println(r);
  
          System.out.println(c > 8 ? 9.9 : 9);//9.0
  ```

- ##### 字符串拼接符

  - ##### 字符是char类型,用单引号来存储,只能存单个字符,必须要存一个

  - ##### 字符串是String类型,用双引号存储,可存多个字符,可以一个不存
    - ##### 使用+号,如果两端都是数值类型,则进行运算操作

    - ##### 使用+号,如果有一端是String类型,则进行拼接操作,变成一个完整的字符串!

```java
		 /**字符串拼接符:
         *使用+号,如果有一端是String类型,则进行拼接操作,变成一个完整的字符串!
         */
        String name = "李浩文";
        System.out.println("这位同学的名字叫做:" + name);
        System.out.println(10+10+""+30); //"2030"
        System.out.println(""+6+6+6);//"666"
        System.out.println(10+10+30+"");//"50"
```

#### 程序结构

> 以后所有程序,不管业务逻辑多复杂,都可以通过程序结构来实现

- ##### 顺序结构:代码逐语句执行,每句代码都执行。

- ##### 分支结构:有条件的执行某个语句,并非每句代码都执行。

- ##### 循环结构:有条件的循环执行语句,并非每句代码都执行。

  

  - ##### 分支结构

    ```java
    例如：
        	购物满500 打8折 ---------条件:购物满500  ----true ----打8折   ---单路分支
                
            购物满500 打8折,不满打9折-条件:购物满500	----true ----打8折
                								  ----false ---打9折   --双路分支
    ```

    1. ##### 单路分支：当对一个判断条件,成立时需要执行某个逻辑代码时使用。

       ```java
       package day03;
       import java.util.Scanner;
       /**
        * 单路分支的使用演示类：
        */
       public class IfDemo {
           public static void main(String[] args) {
               /** 单路分支的语法演示:
                *  if(条件){
                *      当判断的条件为true时,执行的代码块
                *  }
                *  程序执行:
                *         先判断if小括号中的条件是否成立(true)
                *          若为true则执行对应的代码块区域
                */
               //购物金额满500 打8折
               //金额可以通过Scanner方式通过控制台 键入来获取   nextDouble();
               Scanner s = new Scanner(System.in);//创建一个扫描器
               System.out.println("请输入付款金额:回车即可");
               double price = s.nextDouble();//代表购物金额
               if(price >= 500){ //如果金额大于等于500
                   price *= 0.8;//打8折  等价于： price = price *0.8;
                   System.out.println("打完8折后,应付："+price);
               }
               System.out.println("已付款:"+price);
           }
       }
       ```

    2. ##### 双路分支：当对一个条件,条件成立时执行某段代码, 不成立执行某段代码时

       ```java
       package day03;
       
       import java.util.Scanner;
       
       /**
        * 双路分支的使用演示类：
        */
       public class IfElseDemo {
           public static void main(String[] args) {
               /**双路分支的语法演示：
                *  if(判断的条件){
                *      条件成立所执行的代码块
                *  }else{//否则
                *      条件不成立所执行的代码块
                *  }
                *  执行过程:
                *         先去判断小括号中的条件是否成立
                *         若成立 则执行成立对应的代码块
                *         若不成立 则执行不成立对应代码块
                */
               //购物满500 打8折    不满  打9折
               double price = 499;//金额
               if (price >= 500) {//如果金额大于等于500
                   price *= 0.8;//打8折
                   System.out.println("打完8折后应付:" + price);
               } else {//否则
                   price *= 0.9;//打9折
                   System.out.println("打完9折后应付:" + price);
               }
               System.out.println("已付款:" + price);
       
               // 用双路分支 判断a是否是偶数  是偶数 打印偶数  是奇数打印 奇数
               int  a = 15;
               if(a % 2 == 0){
                   System.out.println(a + "是偶数");
               }else {
                   System.out.println(a + "是奇数");
               }
               //简单的返回某个数据 用分支或三元都可以 ,如果成立/不成立需要执行代码逻辑 则需要使用双路分支。
              String  r =   a % 2 == 0 ? "是偶数":"是奇数";
           }
       }
       
       
       ```

    3. ##### 多路分支:当对一个数据有多种判断条件时,使用多路分支的语法.

       ```java
       package day03;
       
       import java.util.Scanner;
       
       /**
        * 多路分支的使用演示类：
        */
       public class IfElseIfDemo {
           public static void main(String[] args) {
               /** 多路分支的使用演示类:
                *  if(条件1){
                *      条件1成立所执行的代码块
                *  }else if(条件2){
                *      条件2成立所执行的代码块
                *  }else if(条件3){
                *      条件3成立所执行的代码块
                *  }
                *  sout(其他代码...); ----顺序结构代码
                *  执行过程：
                *         先判断条件1的结果是否成立 ,若为 true则执行条件1对应的代码块
                *    否则如果判断条件2的结果是否成立 ,若为 true则执行条件2对应的代码块
                *    否则如果判断条件3的结果是否成立 ,若为 true则执行条件3对应的代码块
                *    如果都没成立 代码顺序向下执行了....
                */
               //当对一份数据有多种判断条件时使用
               /**需求: 通过用户输入的分数,来判断用户成绩等级
                * 例如: int score = ?;
                *    A.如果分数 大于等于90            输出优秀
                *    B.如果分数 小于90&&大于等于80      输出良好
                *    C.如果分数 小于80&&大于等于70      输出一般
                *    D.如果分数 小于70&&大于等于60      输出及格
                *    E.如果分数 小于60              输出不及格
                */
       //        Scanner s = new Scanner(System.in);
       //        System.out.println("请输入分数:回车即可");
       //        int score = s.nextInt();//接受控制台中键入的数据
       //        if(score > 100 || score < 0){
       //            System.out.println("分数不合法");
       //        }else if (score >= 90) { //如果分数 大于等于90
       //            System.out.println("优秀");
       //        } else if (score >= 80) {
       //            System.out.println("良好");
       //        } else if (score >= 70) {
       //            System.out.println("一般");
       //        } else if (score >= 60) {
       //            System.out.println("及格");
       //        } else{//否则  代码若执行到改行,则表示上述条件没有一个成立的！
       //            System.out.println("不及格");
       //        }
       //        System.out.println("代码继续向下执行....");
               /**  课堂练习： 通过控制台的方式 获取用户输入的年龄 根据年龄判断人生阶段
                *      int age = ?;
                *      A. 如果    age  大于等于 0 并且小于 5     输出幼年！
                *      B. 否则如果 age 大于等于 5  并且小于18    输出青年！
                *      C. 否则如果 age 大于等于 18 并且小于 35   输出成年！
                *      D. 否则如果 age 大于等于 35 并且小于 50   输出中年！
                *      E. 否则如果 age 大于等于 50 并且小于 65   输出中老年！
                *      F. 否则如果 age 大于等于 65 并且小于 150  输出老年！
                *         否则               输出年龄不合法！
                * */
               Scanner s = new Scanner(System.in);
               System.out.println("请输入年龄,判断人生阶段..");
               int age =s.nextInt();
               if(age >= 0 && age < 5){
                   System.out.println("幼年");
               }else if(age >= 5 && age < 18){
                   System.out.println("青年");
               }else if(age >= 18 && age < 35){
                   System.out.println("成年");
               }else if(age >= 35 && age < 50){
                   System.out.println("中年");
               }else if(age >= 50 && age < 65){
                   System.out.println("中老年");
               }else if(age >= 65 && age < 150){
                   System.out.println("老年");
               }else{
                   System.out.println("年龄输入不合法！！！");
               }
       
           }
       }
       
       ```

       #### 多路分支之Switch

       > ##### 适用性：Switch case只能对数据进行判等的操作.

       ##### 优点：对数据进行判等操作时,效率优于ifelseif结构.  

       ##### switch支持判等的类型有：byte, short int  ,  jdk1.7后支持 String , 枚举类型。

       ##### break:代表的是退出的意思。

       ##### default:相当于如果语句都没匹配上,一个默认会执行的语句。

       ```java
       package day03;
       
       import java.util.Scanner;
       
       /**
        * switch的使用演示类
        */
       public class SwitchCaseDemo {
           public static void main(String[] args) {
               /** switch的语法演示：
                *  需求:模拟客服电话,提示: 1,中文服务 2,英文服务  0,人工服务
                */
               Scanner s = new Scanner(System.in);//创建一个扫描器
               System.out.println("请输入服务按钮:1,中文服务 2,英文服务   0,人工服务");
               int user = s.nextInt();//接收用户输入的指令
               switch (user) { //判断(变量)
                   case 1: //等价于  user == 1
                       System.out.println("中文服务开始了...");
                       break;//代码遇到break,则退出至switch结束花括号位置..
                   case 2://等价于  user == 2
                       System.out.println("英文服务开始了...");
                       break;//代码遇到break,则退出至switch结束花括号位置..
                   case 0://等价于  user == 0     
                       System.out.println("人工服务开始了...");
                       break;//代码遇到break,则退出至switch结束花括号位置..
                   default: //可以理解为else  前提是要有break
                       System.out.println("输入的指令不合法...");
               }
               System.out.pr
                   intln("程序执行完毕...");
           }
       }
       
       ```

  - ##### 循环结构

    > ##### 循环：指的是重复执行的过程。

    ##### Java中的循环分为三种：

    ##### 循环三要素：1. 循环变量初始化  2.基于循环变量的条件  3.循环变量的改变

    ```java
    跑三圈
        						初始圈数 0
    够三圈吗?   不够   跑一圈      圈数自增 1  
    够三圈吗?   不够   跑一圈	  圈数自增 2
    够三圈吗?   不够   跑一圈      圈数自增 3
    够三圈吗?   够了   不跑了....    
        
        三要素：
        		1. int count = 0; //初始圈数为0  初始值 
    			2. count < 3;      //圈数小于3   条件
    			3. count++;        //圈数自增    改变
        
    ```

    1. ##### while: 先判断条件循环条件,再决定是否执行循环,有可能一次都不执行.

       ```java
       package day04;
       
       /**
        * while循环的使用演示类：
        */
       public class WhileDemo {
           public static void main(String[] args) {
               /** while语法:
                *  while(循环条件){
                *      条件成立所执行的代码块
                *  }
                *  sout(其它的代码...);
                * 执行过程：
                *        程序遇到while ,则判断小括号中的条件是否满足
                *        若满足 则执行条件成立所对应的代码块,执行完后,跳到小括号位置继续判断条件是否满足
                *        若满足 则再次执行条件成立所对应的代码块,执行完后,跳到小括号位置继续判断条件是否满足
                *        ....
                *        直至 循环条件不满足 循环退出 继续向下执行其它代码
                */
       
               //局部代码需要循环做好多次...
       //        System.out.println("今晚大家非常棒！！继续保持！");//x3
               //循环三要素：1. 循环变量初始化  2.基于循环变量的条件  3.循环变量的改变
               int count = 0;//表示执行的次数  循环变量
               while (count < 3){//循环条件：count < 3
                   System.out.println("今晚大家非常棒！！继续保持！");
                   count++;//循环变量自增
               }
               System.out.println("程序已结束");
           }
       }
       
       ```

    2. ##### do while： 先做一次循环体,再判断循环条件,至少会执行一次循环体

       ```java
       package day04;
       /**
        * do while循环的使用演示类
        */
       public class DoWhileDemo {
           public static void main(String[] args) {
               /** do while 语法:
                *  do{
                *     循环体..放需要循环执行的代码
                *  }while(循环条件);
                *
                *  执行过程：
                *          第一次先去执行循环体代码,在判断循环条件
                *          若条件为true,再次执行循环体,执行完后,再判断循环条件
                *          若条件为true,再次执行循环体,执行完后,再判断循环条件
                *          ...
                *          直至循环条件为false 循环结束
                */
               //System.out.println("行动是成功的阶梯,大家加油！！！");
               //循环三要素：1. 循环变量初始化  2.基于循环变量的条件  3.循环变量的改变
               int count = 0;//循环变量初始化
               do{
                   System.out.println("行动是成功的阶梯,大家加油！！！");
                   count++;//循环变量改变
               }while (count < 3);//循环条件
               System.out.println("程序结束...");
           }
       }
       ```

       ##### while  和  do while 区别：

       - ##### 相同点： 已知循环条件时,使用的循环！

       - ##### while：    先判断条件,再决定是否执行循环体,有可能一次都不做！

       - ##### do while: 先做一次循环体,再判断循环条件,至少能做一次！

       #### 随机数

       - ##### Java提供了一个可以获取随机数的功能:   Math.random();

       - ##### Math.random();获取随机数功能,返回给一个随机小数double类型。

         #####   数据范围0~1区间的小数,包头不包尾！

         ```java
          /**Math.random() 的使用
                  *Math.random();获取随机数功能,返回给一个随机小数double类型。
                  * 数据范围0~1区间的小数,包头不包尾！包含0 最多到0.9999....
                  */
                 double r1 = Math.random();
         //        System.out.println(r1);
                 //0~100的随机小数
                 double r2 = Math.random() * 100;//0~ 100  包头不包尾！
         //        System.out.println(r2);
                 //0~100的整数 -----强转
                 int r3 = (int) (Math.random() * 100);
         //        System.out.println(r3);
                 //区间随机数： 公式  Math.random() *(最大值-最小值)+最小值
                 //90 ~ 100区间的随机数据
                 int r4 = (int) (Math.random() * (100 - 90) + 90);
                 System.out.println(r4);
         ```

       ##### 需求：猜大小案例

       - ##### 让用户再控制台中输入一个数据，判断用户输入的数据是否与系统产生随机数是否相等

         - ##### 若相等则打印 猜对了！！

         - ##### 若不相等 打印猜错了,并继续让用户猜！直至猜对了为止.

           ```java
           package day04;
           
           import java.util.Scanner;
           
           /**
            * do while循环的使用演示类
            */
           public class DoWhileDemo {
               public static void main(String[] args) {
                   /**猜大小案例需求：
                    *  1.0运行时产生一个随机数0~100,让用户再控制台中输入一个对应范围数据,接收用户输入的数据并判断
                    *     等于. 答对了 或 不等于 答错了
                    *  2.0如果答错了,就要让用户一直猜. 循环条件：只要没猜对就一直猜  user != ran
                    */
                   int ran = (int)(Math.random()*100);//产生一个随机数0~100
                   Scanner s = new Scanner(System.in);
                   int user;
                   do {
                       System.out.println("请输入猜的数据,范围0~99");
                       //变量的可使用范围：在声明的变量时,从上找离变量最近的开始花括号与对应的结束花括号的区间使用。
                       user = s.nextInt();//接收用户输入的数据
                       if(user == ran){//判断用户输入的数据 是否等于 系统产生的随机数
                           System.out.println("答对了！！");
                       }else if(user > ran)  {//如果用户猜的数据大于 ran
                           System.out.println("猜大了！！");
                       }else {//否则就一定猜小了...
                           System.out.println("猜小了！！");
                       }
                   }while (user != ran);
                   //留个作业： 1.将猜大小案例写两遍.看着写一遍 , 删除掉写的代码 根据 需求自己写出来！
                     //       2.思路走一遍将代码的执行过程！
               }
           }
           
           ```

    3. ##### for(最常用)：适合已知循环次数时使用的循环。

       - ##### continue; 关键字作用：当代码遇到continue时,程序跳过当次循环,准备执行下次循环。
    
       - ##### break;  关键字作用: 当代码遇到break时,程序则退出当前循环,执行循环结束后的代码

```java
for的循环变量要写在小括号中,特殊作用:作用范围只在当前for中使用
for(int i = 0; i < 3; i++){

}

for(int i = 0; i < 3; i++){ // 两个for循环的i互不影响.

}
```

```java
package day04;

/**
 * for的使用演示类：
 */
public class ForDemo {
    public static void main(String[] args) {
        /** for的语法
         * 循环三要素：① 循环变量初始化 ;②基于循环变量的条件 ; ③循环变量的改变
         *          ①       ②    ③
         *  for(int i = 0; i < 3; i++){
         *      //④ 循环体
         *  }
         * //其它代码...
         *   执行过程：
         *         先去执行  ①     ②若满足执行    ④
         *         再去执行  ③     ②若满足执行    ④
         *         再去执行  ③     ②若满足执行    ④
         *         再去执行  ③     ..直至②不满足  循环结束...
         *        for(int i =0; i < 3; i++){
         * //            System.out.println("今晚天气好晴朗！！");
         *         }
         *         //continue; 关键字作用：当代码遇到continue时,程序跳过当次循环,准备执行下次循环。
         *         for(int i = 1; i <= 10; i++){
         *            if(i % 2 == 0){
         *               // System.out.println(i + ":是偶数");
         *                continue;//跳过当次循环
         *            }
         *                //System.out.println(i + ":是奇数");
         *         }
         *         //break;  关键字作用: 当代码遇到break时,程序则退出当前循环,执行循环结束后的代码
         *         //让小明同学跑10圈,但是当跑完5圈后 肚子疼不能跑了...
         *         for( int i = 1;i <= 10; i++){
         *             if(i > 5){
         *                 System.out.println("小明不能跑了...肚子疼...");
         *                 break;//退出循环
         *             }
         *             System.out.println("小明正在跑第:" + i + "圈");
         *         }
         *         System.out.println("终于可以歇歇了!!");
         */
       

    }
}


```

```java
 /**continue; 关键字作用：当代码遇到continue时,程序跳过当次循环,准备执行下次循环。
         * continue练习:
         *     求 1 到 100之间 能被3整除的所有数字之和,最后打印和的数值.
         *     提示:在循环中判断当前循环变量是否不能被3整除,若不能则跳过循环
         *         若循环没跳过,则累加当前循环变量.
         *     循环结束后,输出累加的数据.
         *         int sum = 0;//用来记录总和
         *         for (int i = 1; i <= 100; i++) {
         *             if (i % 3 != 0) {//如果循环变量不能被3整除
         *                 continue;//跳过当次循环
         *             }
         *             sum += i;//累加i的值 到sum中.
         *         }
         *         System.out.println("累加1~100之间3的倍数和为:"+sum);
         *
         */
```

```java
    /**break;  关键字作用: 当代码遇到break时,程序则退出当前循环,执行循环结束后的代码
     *  练习:
     *      使用循环统计1~100之间数字和,当和大于等于2500时,循环终止(退出)
     *      1.打印出统计和的数据
     *      2.打印出最后一次累加的那个循环变量数字是多少.
     */
    int sum = 0;//记录和
    for(int i = 1; i <= 100; i++){
        if(sum >= 2500){ //如果累加的变量和大于等于 2500
            System.out.println("最后一次累加的i的值是："+ (i - 1));
           break;//退出循环
        }
        sum += i;//将循环变量累加给sum
    }
    System.out.println("累加和为:"+sum);
```
```java
 /**for循环练习1:
         *    10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
         *    求10的阶乘的结果。
         *    提示：实现10次循环,每次循环 都用一个 sum 累乘 循环变量
         *    循环结束 打印阶乘结果
         *         int sum = 1;//记录10的阶乘结果
         *         for(int i = 1; i <= 10; i++){
         *              sum *= i;
         *         }
         *         System.out.println("10的阶乘结果为:"+sum);
         */

        /** for循环练习2：
         *  求 1 ~ 20以内偶数的次数
         *  提示：实现20次循环,每次循环判断循环变量 % 2 == 0 ,若满足 累加次数1
         *  循环结束 打印统计1~20以内 偶数存在的次数为多少?
         *          int count = 0;//记录偶数次数
         *          for(int i = 1; i <= 20; i++){
         *              if(i % 2 == 0){//如果i 是偶数
         *                 count++; //则累计一次
         *              }
         *          }
         *         System.out.println("1~20以内 偶数存在的次数为："+count);//10
         */
        /**for循环练习3:
         *  需求：运行程序后,生成10道随机的1~100的加法题,然后每次生成完让用户输入答案,判断用户输入的答案是否
         *  正确。
         *      正确：打印正确  错误 :打印错误
         * 提示:   1.0  先出一道题  1.出题   2.答题  3.判题
         *        2.0  再想10道题
         *        扩展：声明一个score变量, 每次答对了+10分  等整体答完以后,判断分数等级...
         *  运行后：
         *        (1) 50 + 50 = ?
         *        请回答！
         *        100
         *        正确！
         *        (2) 88 + 99 = ?
         *        请回答！
         *        187
         *        正确！
         *        (3) .....
         *        (10) 1 +  1 = ?
         *        请回答！
         *        3
         *        错误！
         *
         Scanner s = new Scanner(System.in);//创建一个扫描器
         int score = 0;//用来记录分数
         for (int i = 1; i <= 10; i++) {
         //1.出题：随机 0 ~ 100 加法题
         // (1) 随机 + 随机 = ?
         int r1 = (int) (Math.random() * 100);//生成0~99的随机数
         int r2 = (int) (Math.random() * 100);//生成0~99的随机数
         System.out.println("(" + i + ") " + r1 + " + " + r2 + " = ?");
         //2.答题 接收用户再控制台中输入的数据
         System.out.println("请回答！");
         int user = s.nextInt();//接收用户输入的整数
         //3.判题 判断用户输入的数据是否等于 系统产生的随机数和
         if (user == (r1 + r2)) {
         score += 10;//答对10分
         System.out.println("答对了！！");
         } else {
         System.out.println("答错了！！");
         }
         }
         //循环结束 score则是答题完后的得分。
         */

```

#### 双重for循环

> for循环嵌套，一般循环嵌套不能超过3层
>
> 案例：九九乘法表

##### 外层for:用来控制轮数的     用于控制行数

##### 内层for:用来控制次数的     用于控制列数

```java
for(){
    for(){
       
    }   
}
---
    package day04;

/**
 * 双重for循环的使用演示类：
 */
public class ForDemo02 {
    public static void main(String[] args) {
        //实现需求：九九乘法表
        //分解需求:  3的乘法表
        //格式：  1 * 3 = 3    2 * 3 = 6   3 * 3 = 9
        for(int num = 1; num <=9; num++){ //控制轮数

            for(int i = 1; i <= num; i++){//控制次数               //tab
                System.out.print(i +" * " + num +" = " +(i * num)+"\t");
            }
            System.out.println();//换行
        }
    	 //需求: 打印5行5列的☆
        for(int i = 1; i <= 5; i++){//控制行数
            for(int j = 1; j <= 5; j++){//控制列数
                System.out.print("★");
            }
            System.out.println();//换行
        }	    
    }
}
```

#### 数组

> 数组是一种数据结构,是引用类型。

##### 定义：数组是可以存储同一类型的多个元素的结构,可以理解为数组就是一个容器,可以存储多个元素

```java
可以把数据结构理解为:  衣柜  鞋柜   橱柜

int a;//声明了一个int类型的变量,名为a   		  ---------变量里面只能存储一个数据
int[] array;//声明了一个int类型的数组,数组名为array---------可以存储多个整数数据,存多少取决于开辟空间
double[] arr1;//声明了一个double类型数组,数组名为arr1-------可以存储多个小数数据,存多少取决于开辟空间
```

- ##### 数组的声明和初始化

- ##### 数组的访问

```java
        //1.数组的声明
        int[] a;//声明了一个int类型的数组
        //2.数组的初始化,分为两种 ： 静态初始化   动态初始化
        //静态初始化：当声明数组时,已知存储的元素个数和数据时使用
        int[] arrA = {5,10,15,20,25};
        //动态初始化:当声明数组时,已知存储的元素个数时使用。
        int[] arrB = new int[3];//创建了int数组并开辟了3块空间
        //3.数组的访问
        arrB[0] = 100;//为arrB数组下标0区域,赋值数据100
        arrB[1] = 200;//为arrB数组下标0区域,赋值数据100
        arrB[2] = 300;//为arrB数组下标0区域,赋值数据100
//        arrB[3] = 1000;//数组下标访问越界异常:ArrayIndexOutOfBoundsException
        System.out.println(arrB[0]);//100
        System.out.println(arrB[1]);//200
        System.out.println(arrB[2]);//300
```



- ##### 数组的遍历

  ```java
   //4.数组的遍历:遍历指的是依次访问数组中每个元素的过程
  //        int[] array = {10, 20, 30, 40, 50, 60};
  //        //数组的长度: 数组名.length
  //        for (int i = 0; i < array.length; i++) {
  //            System.out.println(array[i]);
  //        }
  //        System.out.println(array[0]);
  //        System.out.println(array[1]);
  //        System.out.println(array[2]);
  //        System.out.println(array[3]);
  //        System.out.println(array[4]);
  //        System.out.println(array[5]);
          // 练习: 通过程序 求出array数组中所有元素和
  //        int sum = 0;//记录和
  //        int[] array = {10, 20, 30, 40, 50, 60};
  //        for (int i = 0; i < array.length; i++) {
  //            sum += array[i];   // array[i]代表数组中的每个元素
  //        }
  //        System.out.println("sum累加数组中的和为:"+sum);
  
          //练习：通过运行程序,在控制台中依次录入10名同学的成绩,存到一个数组中
          //数组名 ：  scores
          //思考？数组开辟多少块空间
          //     1.0 完成运行时录入10名同学成绩
          //2.0 求10名同学的平均成绩是多少?  班级总分 / 人数
          //运行过程：
          /**       请输入第1名同学的成绩
           *        88
           *        请输入第2名同学的成绩
           *        90
           *        ...
           *        请输入第10名同学的成绩
           *         60
           *        录入完毕.
           *                Scanner s = new Scanner(System.in);
           *         int[] scores = new int[10];//开辟10个空间
           *         int sum = 0;//用来记录总成绩
           *         for (int i = 0; i < scores.length;i++){
           *             System.out.println("请输入第"+ (i+1) +"名同学成绩");
           *             scores[i] = s.nextInt();//依次接收用户在控制台中的数据 存给数组的每块空间
           *             sum += scores[i];//累加和到sum
           *         }
           *         System.out.println("10名同学的平均成绩为:"+ sum / scores.length);
           */
  
  
          /** 练习：
           *      已知数组： int[] arrA = {30,70,20,88,999,50};
           *      需求:通过程序 求出arrA数组中最大值
           *      思路：1.假设数组中第一个元素是最大值, 声明个变量  int max = arrA[0];
           *           2.遍历当前数组,拿max依次与数组中的每个元素比较
           *           3.若max小于arrA[i]  则将 max = arrA[i]; 始终保持max最大
           *           循环结束 输出max 则拿到最大值
           */
          int[] arrA = {30, 70, 20, 88, 999, 50};
          int max = arrA[0];//假设数组的第一个数据是最大值
          int maxIndex = 0;//假设最大值的下标是0
          for (int i = 0; i < arrA.length; i++) {
              if(max < arrA[i]){
                 max = arrA[i];//将当前大于max 的数据 赋值给max 始终保持max最大
                 maxIndex = i;//将最大值下标进行重新赋值。
              }
          }
          System.out.println("arrA数组最大值是:"+max+"对应在数组中的下标是："+maxIndex);
     /**需求 ：随机生成4位验证码。
           *   思路： 1.声明一个char数组开4个空间  用来装随机出来的字符数据。 char[] code = new char[4];
           *         2.获取随机数, 随机范围就是 0 ~ codes.length  (int)(Math.random()*codes.length)
           *         3.codes[随机数] 将对应的字符 依次赋值给code数组
           *      最后遍历输出随机的验证码 ----遍历code数组。
           *
           *      不重复的验证码的情况:
           *      1.可以做一个boolean类型的数组,长度跟codes保持一致  new boolean[codes.length];
           *         boolean0~35的值都是false
         *      2.随机一个整数数据  第一次假设随机到的数据是 0   将随机到的 0   c[i] = codes[0];
           *        同时还要将  boolean[0] 修改为true
           *       下次随机到的数据还是0  判断boolean[0] 若为true 则表示当前已经随机到过了 直接continue  
           *      while(true){
           *          //退出的条件  例如当index的数据自增到4  退出循环 break
           *      }
           */
          char[] codes = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0'};
          char[] c = new char[4];//用来存储随机出的字符
          //36
          for (int i = 0; i < c.length; i++) {
              int ranIndex = (int) (Math.random() * codes.length);//每次循环生成一个随机数
              c[i] = codes[ranIndex];//将随机的数据 当做取codes数组中的元素下标,来随机取出数据给c数组依次复制
          }
          for (int i = 0;i<c.length;i++){
              System.out.print(c[i]);
          }
  ```
  
  ### 方法
  
  > 方法表示的就是功能(工具)

##### 定义:在程序中,可以使用方法根据业务逻辑功能模块化进行包装,目的便于调用和查找！

##### 适用性：当在程序中,有一段业务逻辑代码表示的是功能,且非常常用,我们使用方法可以实现复用逻辑的操作.能达到一次定义多次使用的过程.

- ##### 方法的语法:   [访问修饰符]  返回值类型  方法名([参数列表]){   方法体  }

  - ##### 访问修饰符: 控制代码的可见范围(后续讲)

  - ##### 返回值类型：如果方法没有返回值类型 该位置用void来表示。

    - ##### 	如果方法有返回值,则在该位置写上需要返回值的类型 且在方法结束的花括号之前写上

    - #####    return  需要返回的具体数据；   return -----表示退出方法并返回后面数据。

    - ##### 如果方法没有返回值是void 也可以写return ; ,不过则表示是退出方法!

  - ##### 方法名：小驼峰命名法（见名知意）

  - ##### 参数列表：形式参数,当方法中处理的业务逻辑过程有一些无法确定的数据,可以通过外部调用方法的时候,,传递过来具体的内容。

  - ##### 方法体：存放方法逻辑的位置

- ##### 方法的形式：

  - ##### 无参无返回值:只是仅仅为了包装一段重复业务代码时,没有其它需求,可使用无参无返回值方法

    ```java
    package day05;
    
    /**
     * 无参无返回值方法的使用演示：
     */
    public class MethodDemo01 {
        public static void main(String[] args) {
            //代码逻辑重复！且一旦需求发生改变,全部都要变！
    //        System.out.println("一个右鞭腿");
    //        System.out.println("一个左刺拳");
    //        System.out.println("一个过肩摔");
    //        System.out.println("年轻人！耗子尾汁！");
    //        System.out.println("你过来啊！！");
    //
    //        System.out.println("一个右鞭腿");
    //        System.out.println("一个左刺拳");
    //        System.out.println("一个过肩摔");
    //        System.out.println("年轻人！耗子尾汁！");
    //        System.out.println("你过来啊！！");
    //
    //        System.out.println("一个右鞭腿");
    //        System.out.println("一个左刺拳");
    //        System.out.println("一个过肩摔");
    //        System.out.println("年轻人！耗子尾汁！");
    //        System.out.println("你过来啊！！");
            attack();//调用方法
            attack();//调用方法
            attack();//调用方法
        }
        //方法的语法：  返回值类型  方法名(){   方法体  }
        //自定义方法,如果不被调用是不会被执行的！
        //static不是方法的必要语法：目前加static只是为了再main调用测试。
        //好处：一次定义多次调用！实现逻辑复用！且若修改只需要修改一次即可！
        //无参数无返回值方法的定义：当只是仅仅包裹一段重复的业务逻辑代码时,且不需要参数内容和返回值类型的情况下使用。
        static void attack() {//定义方法
            System.out.println("一个右鞭腿");
            System.out.println("一个左刺拳");
            System.out.println("一个过肩摔");
            System.out.println("年轻人！耗子尾汁！");
            System.out.println("你过来啊！！");
            System.out.println("只需要改一次！");
        }
    
    
    }
    
    ```

  - ##### 有参无返回值：当方法中定义逻辑时,有些数据无法确定下来,那么我们可以将这个数据 作为形式参数

    ```java
    package day05;
    
    /**
     * 有参数无返回值方法的使用：
     */
    public class MethodDemo02 {
        public static void main(String[] args) {
    //        //调用方法时：要根据方法语法来使用该方法的规则：  传递对应参数类型的值 为实际参数
    //        String name = "金磊";
    //        int age = 33;
    //        sayHi(name,age);//调用方法
    //        sayHi("步挺",33);//调用方法
    //        //s.next(); //接收键入String类型的数据
            int[] arr1 = {1,2,3,4,5,6,7};
            for (int i = 0; i < arr1.length; i++){
                System.out.print(arr1[i]+"\t");
            }
            System.out.println();
            int[] arr2 = {5,6,7,8,9,10};
            for (int i = 0; i < arr2.length; i++){
                System.out.print(arr2[i]+"\t");
            }
            System.out.println();
            int[] arr3 = {40,50,60,70,80};
            for (int i = 0; i < arr3.length; i++){
                System.out.print(arr3[i]+"\t");
            }
        }
        
    
        /**做一个打印数组中数据的功能的方法    方法名：printArray
         *  当方法中定义逻辑时,有些数据无法确定下来,那么我们可以将这个数据 作为形式参数
         *  形式参数的好处:1.可以将方法的内部逻辑定义完整 2.参数内容具体是什么 由使用功能的人来决定
         *  形式参数格式：  数据类型  变量名
         *  有参数无返回的方法
         *
         */
    
        //方法表示的是功能！
        //需求：做一个问好的功能  sayHi   功能需要通用的！
        //方法的语法：  返回值类型  方法名(){   方法体  }
        //目的：希望谁调用sayHi 谁决定问谁好！
        /**方法参数又叫做：形式参数,当方法中处理的业务逻辑过程有一些无法确定的数据,
         * 可以通过外部调用方法的时候,传递过来具体的内容。
         * 形式参数： 参数类型 变量名(提示外部使用方法时传递过来的数据内容)
         * 形式参数好处：1.无法确定方法逻辑的数据时,可以将方法的内容完整 2.形式参数的内容是什么由调用者决定！(灵活)
         * 原则：方法尽可能定义的灵活一些！不能因为需求发生改变 导致方法频繁被修改！
         */
        static void sayHi(String name,int age){ //自定义方法需要调用才能执行！
            System.out.println( name + "同学你好！,我的年龄是:"+age);
        }
    } 
    /**       
    * 		//打印数组的功能方法
    *       static void printArray(int[] arr){
    *        for (int i = 0; i < arr.length; i++){
    ```
  *            System.out.print(arr[i]+"\t");
    
    *        }
  *        System.out.println();//换行
    *    }
  *
    */
    ```
    
    ```
  
  - ##### 无参有返回值:当方法表示的是获取什么内容的方法时,方法被调用后,需要返回给调用者一些数据时使用.
  
    ```java
    package day05;
    
    import java.util.Scanner;
    
    /**
     * 无参数有返回值的方法使用演示：
     */
    public class MethodDemo03 {
        public static void main(String[] args) {
            //调用的方法如果有返回值的话,若只是想要输出该方法返回的数据,我们可以将调用的方法套在打印语句中
            System.out.println(getPi()); //3.1415926
            double p = getPi();
            System.out.println(p);
            double ran = Math.random();//获取随机数的功能 返回0~1 的随机小数 double
    //        Scanner s = new Scanner(System.in);
    //        double user= s.nextDouble();
            System.out.println(Math.PI);
        }
        /**
         * 需求：做一个获取PI值的功能方法
         * 目的: 让调用者可以通过该功能,获取到一份数据PI: 3.1415926
         */
        //方法语法： 返回值类型  方法名(){   方法体  }
        //注意:一旦方法有返回值类型,那么在方法体的结束花括号之前要写return 语句 返回要返回的数据才可以!
        //return  需要返回的具体数据；   return -----表示退出方法并返回后面数据。
        static double getPi() {
            return 3.1415926;
        }
    
    }
    
    ```
  
  - ##### 有参有返回值:一般用来计算逻辑,或算法的实现时使用,需要外部传入数据 并返回 逻辑的结果时使用.
  
    ```java
    package day05;
    
    /**
     * 有参数有返回值的方法演示:
     */
    public class MethodDemo04 {
        public static void main(String[] args) {
            int s = sum(10, 20);
            System.out.println(s);
            double s1 = sum(1.5, 6.9);
            System.out.println(s1);
            System.out.println( sum(10,20,30));
            //我们经常用的打印语句也使用的重载!方便使用者只关心打印的数据
            System.out.println(10);
            System.out.println(1.235);
            System.out.println('A');
            System.out.println(true);
            System.out.println("abcd!");
        }
        /**
         * 需求1:写一个计算和的功能方法.
         * 目的:通过外部传入两个int类型的数据 ,方法中计算传入进来的数据相加和,并返回给调用者
         * 有参:为了让调用方法的人决定计算什么数据.
         * 有返回值:计算后将结果给调(使)用者
         */
        static int sum(int a, int b) {//满足个数不同
            return a + b;
        }
        /**
         * 需求2:写一个计算和的功能方法
         * 目的：通过外部传入两个double类型的数据 ,方法中计算传入进来的数据相加和,并返回给调用者
         */
        static double sum(double a, double b) {//满足类型不同
            return a + b;
        }
        /**
         * 需求3：写一个计算和的功能方法
         * 通过外部传入的3个数据,计算3个整数的和并返回
         */
        static int sum(int a, int b, int c) {//满足个数不同
            return a + b + c;
        }
        //需求4！5 6  7 ........
    
        //当我们在定义功能方法时,往往需求是多变的！那么就意味可能同一个功能,要做n多个方法
        //缺点：对于使用者来讲不友好！需要记不同的方法名 使用对应的功能！
        //解决：当多个方法表示的功能是一致时,但是由于参数个数不同或参数类型不同 导致的多个方法时
        //    可以用方法的重载来解决!
        //重载定义: 当多个方法表示的功能是一致时,满足参数个数或参数类型不同 时,可以使用同一个方法名表示!
        //重载好处: 方便调用者无需区分同一个功能的方法名,系统会自动根据调用者传入的参数个数或类型来匹配对应已定义方法
    }
    
    ```

#### 方法的重载

##### 定义：当多个方法表示的功能是一致时,满足参数个数或参数类型不同 时,可以使用同一个方法名表示!

##### 好处：方便调用者无需区分同一个功能的方法名,系统会自动根据调用者传入的参数个数或类型来匹配对应已定义方法

```java
    static int sum(int a, int b) {//满足个数不同
        return a + b;
    }
    /**
     * 需求2:写一个计算和的功能方法
     * 目的：通过外部传入两个double类型的数据 ,方法中计算传入进来的数据相加和,并返回给调用者
     */
    static double sum(double a, double b) {//满足类型不同
        return a + b;
    }
    /**
     * 需求3：写一个计算和的功能方法
     * 通过外部传入的3个数据,计算3个整数的和并返回
     */
    static int sum(int a, int b, int c) {//满足个数不同
        return a + b + c;
    }
```

#### 方法的强化

```java
 /** 需求: 做一个求int数组最大值的功能方法
     *  目的: 需要外部传入一个int数组,根据传入的数据求出该数组的最大值,并返回最大值
     *  方法名:  getMaxByArray
     *
     */
    //方法语法: 返回值类型 方法名(){ }
    static int  getMaxByArray(int[] arr){
        int max = arr[0];//假设数组的第一个数据是最大值
        for (int i = 0; i < arr.length; i++) {
            if (max < arr[i]) {
                max = arr[i];//将当前大于max 的数据 赋值给max 始终保持max最大
            }
        }
        return max;
    }

```

#### 方法的练习:

##### 简单题目

- ##### 需求:写一个功能,根据外部传入的两个整数数据,以及一个操作数char值来实现运算并返回结果.

- ##### 例如:   调用方法:    operation(10,20,'+')   那么方法返回的结果则是30

- ##### 操作数就是char类型, 分别有'+'   '-'   '*'   '/'  实现四则运算.   if(操作数 == '+') {  返回相加结果 }

  ```java
  static int operation(int a, int b, char c) {
          if (c == '+') {
              return a + b;
          } else if (c == '-') {
              return a - b;
          } else if (c == '*') {
              return a * b;
          } else if (c == '/') {
              return a / b;
          }
          System.out.println("不合法");
          return  -1;
      }
  ```

  

##### 困难题目:

- ##### 需求:有以下数组 array, 通过实现一个反序功能,可以将该数组的内容实现反序.

- ##### int[] array = { 1 ,2 ,3 ,4, 5, 6 ,7}

- ##### 例如: 调用方法: reversalArray( array)   那么方法执行完以后

- ##### array数组中的数据 则 array 中数据为 7  6  5  4  3  2  1 

- ##### 思路: 

  - ##### 已知下标0是第一个元素,  数组名.length-1 是数组最后一次元素

  - ##### 我们将第1个与倒数第一个交换,然后依次第二个和倒数第二个交换,第三个与倒数第三个交换...

  - ##### 数组7个数那这个过程需要执行几次?则表示需要几次循环.

  - ##### 思考?两个变量如何交换?   可以借助第三个变量 int  temp ; 来完成.  

- ##### 数组中最后一个元素下标     数组名.length - 1  

  ```java
      static void reversalArray(int[] array){
          for(int i = 0; i < array.length/2; i++){
              int temp  = array[i];
              array[i]  =  array[array.length-1- i];
              array[array.length-1- i] =  temp;
          }
      }
  ```

# FOUNDATION02

### 面向对象

#### OO(Object Oriented) ：面向对象

#### OOA：面向对象的分析

#### OOD：面向对象的设计

#### OOP：面向对象的编程

#### 面向对象可以写出高质量代码

--------

#### 高质量代码：复用性要好,扩展性要好,维护性要好,可读性要好,健壮性要好,效率好,移植性好

##### 学完面向对象后：

##### 听不懂我在讲什么------落课      3

##### 晕晕乎乎的,能听懂啥意思----正常    2  

##### 大概都听懂了,如果让自己设计设计不出来----优秀  1

> ##### 要求大家最好上课的内容听两遍

#### 对象和类

##### 类：抽象的,不具体,通常表示一类事物的统称.               在程序中表示的是模板..

##### 对象:具体的,真实存在的.												  在程序中表示的是内存中的实例(对象)

#### 面向对象的三大特征：

##### 分析项目中的对象有哪些?

- ##### 一个战舰,一堆炸弹,一堆侦查潜艇,一堆鱼雷潜艇,一堆水雷潜艇,一堆鱼雷,一堆水雷

##### ObserverSubmarine(侦察对象)

##### os1 ----------------------------->width  ,  height ,  x   ,   y   , speed

##### os2 ----------------------------->width  ,  height ,  x   ,   y   , speed

##### os3 ----------------------------->width  ,  height ,  x   ,   y   , speed

##### os4 ----------------------------->width  ,  height ,  x   ,   y   , speed

.....

##### os100------------------------->width  ,  height ,  x   ,   y   , speed

##### 100个侦查潜艇对象,就要写100份对应的数据   ! (代码冗余!!)

#### 可以使用类来解决!

##### 可以通过模板类 来批量产生多个对象.

- ##### 封装

  - ##### 类封装的定义:将一类别下多个对象共有的数据和行为封装到一个模板类中,可以通过类来批量产生该对象.

    1. ##### 如何创建类

       - ##### 类:是一种自定义的数据类型,引用类型.

       - ##### 类中放当前类的所有对象共有的数据/属性  ------  变量

       - ##### 类中放当前类的所有对象共有的行为/方法  ------  方法

       ```java
       class Person{ //人类
           //共有数据
           String name;//姓名
           int age;//年龄
           char sex;//性别
           
           //共有行为
           void  eat(){  }
           void sleep(){  }
           void play(){   }
       }
       class Car{//车类
           //数据
           String color;//颜色
           double price;//价格
           String type;//型号
           //行为
           void move(){  }
           void back(){  }
           void stop(){  }
       }
       
       class ObserverSbumarine{ //侦查潜艇类
           //共有数据
           int width;
           int height;
           int x;
           int y;
           int speed;
           //共有行为
           void step(){//移动..
               
           }
       }
       --------------------------------------
         
           
       ```
    
     package oo.day01;
    
     /**
        * 学生模板类  ---放所有学生对象共有的数据和行为
        * 注意：模板类不需要添加main方法！
        */
       public class Student {
           
           //共有的数据      全局变量:作用范围在整个类中
           String name; //姓名
           int age;//年龄
           int stuId;//学号
           
           //共有的行为
           void study(){
       //        int a = 1;  局部变量:作用范围在当前方法中
               System.out.println(name + "在学习");
           }
           void sayHi(){
               System.out.println("你好,我叫："+name+"今年:"+age+"岁了,我的学号是:"+stuId);
           }
       }
    
       ```
    
       ##### 变量的作用域分类:
    
       - ##### 全局(成员)变量:在类中声明的变量,称之为全局变量,作用范围在整个类中可见.
    
       - ##### 局部变量:在方法中声明的变量,称之为局部变量,作用范围在当前声明的方法中.
    
    2. ##### 如何创建对象
    
       ```java
       数据类型  对象名    创建  xxx对象();
       Scanner   s =  new Scanner();//创建一个扫描器对象
       
       Student  zs =  new Student();//创建了一个学生对象
       Student  ls =  new Student();//创建了一个学生对象
       Student  ww =  new Student();//创建了一个学生对象
       ```
    
    3. ##### 如何访问对象
    
       ```java
       package oo.day01;
       
       /**
        * 学生类的测试类:
        * 1.创建对象
        * 2.访问对象
        */
       public class StudentTest {
           public static void main(String[] args) {
               Student zs = new Student();//创建了一个学生对象,将对象存储给 zs中
               //1. 创建的对象中有什么属性(数据),取决于模板类.
               //2. 编译期:zs这个变量,能打点调用出什么内容,取决于变量的类型中有什么!
               //3. 运行期:zs这个变量,打点访问的内容中具体是什么数据,取决于对象!
               zs.name = "张三";
               zs.age = 18;
               zs.stuId = 1001;
               zs.study();//zs这个对象调用学习的方法
               zs.sayHi();//zs这个对象调用sayHi的方法
       
               Student ls = new Student();//创建了一个学生对象,将对象存储给 ls中
               ls.name = "李四";
               ls.age = 28;
               ls.stuId = 1002;
               ls.study();//ls这个对象调用学习的方法
               ls.sayHi();//ls这个对象调用sayHi的方法
       
               //区分: 类与类之间功能上的区分   --   对象跟对象之间数据上的区分
       
       //        System.out.println( zs.name );//张三
       //        System.out.println( zs.age);  //18
       //        System.out.println( zs.stuId);//1001
           }
       }
       ```

##### 项目搭建

```java
1.识别对象:
	     战舰类,炸弹类,侦察潜艇类,鱼雷潜艇类,水雷潜艇类,鱼雷类,水雷类
2.分配职责:
		 战舰类(玩家):发射炸弹
         炸弹类     :攻击三种潜艇,打到
             		1.炸弹消失,被打到的潜艇消失
             		2.打到不同的潜艇加分或加命
         鱼雷潜艇   :发射鱼雷 
         水雷潜艇   :发射水雷
         鱼雷和水雷 : 攻击战舰并扣减战舰的生命值    
3.建立交互....
```

- ##### 在src文件下,创建一个项目包:  cn.tedu.submarine

- ##### 在当前 cn.tedu.submarine包下创建7个类

```java
战舰类: Battleship
    数据(变量): int width;  int height;  int x;  int y; int speed;  int life;(战舰特有)
	行为(方法): void step(){ }
炸弹类: Bomb
    数据(变量): int width;  int height;  int x;  int y; int speed;
	行为(方法): void step(){ }
侦查潜艇类: ObserverSubmarine
    数据(变量): int width;  int height;  int x;  int y; int speed;
	行为(方法): void step(){ }
鱼雷潜艇类: TorpedoSubmarine
    数据(变量): int width;  int height;  int x;  int y; int speed;
	行为(方法): void step(){ }
水雷潜艇类: MineSubmarine
    数据(变量): int width;  int height;  int x;  int y; int speed;
	行为(方法): void step(){ }
水雷类: Mine
    数据(变量): int width;  int height;  int x;  int y; int speed;
	行为(方法): void step(){ }
鱼雷类: Torpedo
    数据(变量): int width;  int height;  int x;  int y; int speed;
	行为(方法): void step(){ }
```

```java
package cn.tedu.submarine;

/**
 * 游戏窗口(运行)类:
 */
public class GameWorld {
    //全局变量
    Battleship ship;
    Bomb bomb;
    ObserverSubmarine os;
    TorpedoSubmarine ts;
    MineSubmarine ms;
    Torpedo t;
    Mine m;
    void action(){//普通方法 用来创建各类型对象的方法
        System.out.println("action执行了!!");
        ship = new Battleship();
        bomb = new Bomb();
        os = new ObserverSubmarine();
        ts = new TorpedoSubmarine();
        ms = new MineSubmarine();
        t = new Torpedo();
        m = new Mine();
    }
    public static void main(String[] args) {
        GameWorld gw = new GameWorld();
        gw.action();//通过对象来调用action方法.
    }
}

/**
 * 1.为什么要将各类型变量的声明放在main的外部?
 * 答:因为main是一个方法,在方法中声明的变量只能在该方法中使用,但后期该类中很多功能方法都需要用到这些对象,
 * 所有将各类型变量声明的工作 放在类中,做成全局变量.
 * 2.为什么要单独写一个action方法,来进行创建对象?
 * 答:因为main是static标记的方法,比较特殊,是无法直接访问类中的普通成员(全局变量/普通方法)等,所以单独做一个
 *   普通方法,在普通方法中完成创建对象的工作.
 * 3.为什么要在main中创建GameWorld类对象调用action方法?
 * 答:因为main是static标记的方法,比较特殊,是不能直接访问类中的普通成员(全局变量/普通方法)等,我们通过
 *   创建当前类对象的形式,通过对象打点调用action方法也可以.
 */

```

#### 内存图

> 默认值:指的是不同类型的变量声明以后,没有赋值时会有一个默认的数据.

- ##### 基本数据类型的默认值: 整数类型默认值是0  ,小数类型默认值是0.0  ,   boolean类型 默认值是false

- ##### 引用数据类型的默认值:   null        --->引用类型目前接触到的:(String,数组,自定义的类型)等

  - ##### 使用引用类型时需要注意,当使用null打点访问内容时,运行则报异常:NullPointerException空引用异常

    > 引用类型的变量存储的是对象地址 ,  基本数据类型的变量存储的是 值 !

- ##### 运行时内存由JVM来划分:   栈区,堆区,方法区(后续会讲)

  - ##### 栈区:放局部变量的区域,局部变量指的是方法中声明的变量,特点:方法执行在栈中,方法执行完,那么局部变量也会被销毁.

  - ##### 堆区:放对象的区域,对象指的是通过引用类型创建的对象! 特点:堆区的对象若没有被使用,则变为内存垃圾。

  - ##### GC（垃圾回收器）：会不定时的扫描内存中的垃圾并回收(清理).

- ##### 创建的对象的内存图

- ##### 基本数据类型数组的内存图

- ##### 引用数据类型数组的内存图

##### 问题:在GameWorld类中的action方法里,创建每一个对象,都要为该对象依次打点赋值,如果同一类型存在多个对象,那么依次打点赋值的过程非常冗余繁琐!

##### 解决：可以通过构造方法来解决！

#### 构造方法

> 构造方法又称为构造器

- ##### 适用性：在创建对象时,可以通过构造方法快速为当前对象初始化赋值数据！

- ##### 构造方法的语法：类名(){   }        -----注意构造方法没有返回值那一说。

- ##### 本质作用：是创建对象的必要语法！

  - ##### 现象1：如果一个类,不添加构造方法,则送一个默认的无参数构造方法

  - ##### 现象2：如果类中添加了任意的构造方法,系统不再赠送！

- ##### 构造方法在类被创建对象时执行！

- ##### 构造方法的重载:只要满足参数类型不同或个数不同即可！

  ```java
   Student(String name1,int age1,int stuId1){
          this.name = name1;
          this.age  = age1;
          this.stuId = stuId1;
      }
      Student(){//无参构造方法
  
      }
  ```

  ##### 测试：

  ```java
  Student zs = new Student("张三",18,1001);//创建对象的语法
          System.out.println(zs.name);//张三
          System.out.println(zs.age);//18
          System.out.println(zs.stuId);//1001
  
          Student ls = new Student("李四",28,1002);
          System.out.println(ls.name);//李四
          System.out.println(ls.age);//28
          System.out.println(ls.stuId);//1002
  ```


#### this关键字

> ##### 注意:Java是允许局部变量与全局变量命名一样的!使用的时候,遵循就近原则.

##### 如果想要明确区分全局变量和局部变量,我们可以明确使用关键字this代表访问的是类中的全局变量!

- ##### 编译期间:this 代表的是当前类,所以可以用this.调用出当前类的成员(全局变量,普通方法)

- ##### 运行期间:this 代表的则是对象,具体this指代是哪个对象,要看谁调用这个方法.

```java
main{
        Student zs = new Student("张三",18,1001);//创建对象的语法
        zs.study(); ----- 方法中用到this 则指代的是 zs
        Student ls = new Student("李四",28,1002);
    	ls.study(); ----- 方法中用到this 则指代的是 ls
}
```

#### 项目问题:解决为项目中各类型对象赋值的问题,为各个模板类添加构造方法.

```java
  Battleship(){//因为战舰只会存在一个对象,且一开始战舰各种数据 都是确定好的  所以做无参构造方法
        width = 66;
        height = 26;
        x = 270;
        y = 124;
        speed = 20;
        life = 5;
    }
--
      //宽,高 确定   炸弹对象的xy坐标是多少,谁创建 谁负责
    Bomb(int x, int y) {
        width = 9;
        height = 12;
        this.x = x;
        this.y = y;
        speed = 3;
    }
---
     Mine(int x, int y) {//水雷类的构造方法
        this.x = x;
        this.y = y;
        width = 11;
        height = 11;
        speed = 2;
    }
--
 Torpedo(int x,int y){
        this.x = x;
        this.y = y;
        width = 5;
        height = 18;
        speed = 2;
    }
-
侦察潜艇类构造方法：
      ObserverSubmarine() { //侦察潜艇类构造方法
        width = 63;
        height = 19;
        x = -width;
        y = (int) (Math.random() * (479 - height - 150) + 150);
        speed = (int) (Math.random() * (3 - 1) + 1);
    }
水雷潜艇类构造方法：
     MineSubmarine() { //水雷潜艇类构造方法
        width = 63;
        height = 19;
        x = -width;
        y = (int) (Math.random() * (479 - height - 150) + 150);
        speed = (int) (Math.random() * (3 - 1) + 1);
    }
鱼雷潜艇类构造方法：
     TorpedoSubmarine() { //鱼雷潜艇类构造方法
        width = 64;
        height = 20;
        x = -width;
        y = (int) (Math.random() * (479 - height - 150) + 150);
        speed = (int) (Math.random() * (3 - 1) + 1);
    }
```

#### 问题：除了战舰,其它类型的对象都会存在多个,如何存储同一类型的多个对象？

##### 解决：使用数组来解决.

```java
    //全局变量
    Battleship ship = new Battleship();
    Bomb[] bombs;
    TorpedoSubmarine[] ts;
    ObserverSubmarine[] os;
    MineSubmarine[] ms;
    Torpedo[] t;
    Mine[] m;
```

##### action方法修改:

```java
void action() {//普通方法 用来创建各类型对象的方法
        //同步练习: 分别为上述数组创建数组对象开辟两块空间 并为对应空间赋值对象!
        bombs = new Bomb[2];//创建了一个炸弹数组 开辟2块空间
        bombs[0] = new Bomb(50, 20);//为下标0 赋值一个炸弹对象
        bombs[1] = new Bomb(50, 40);//为下标1 赋值一个炸弹对象
        ts = new TorpedoSubmarine[2];//创建了一个鱼雷潜艇数组 开辟2块空间
        ts[0] = new TorpedoSubmarine();//为下标0 赋值一个鱼雷潜艇对象
        ts[1] = new TorpedoSubmarine();//为下标1 赋值一个鱼雷潜艇对象
        os = new ObserverSubmarine[2];  //创建了一个侦察潜艇数组 开辟2块空间
        os[0] = new ObserverSubmarine();//为下标0 赋值一个侦察潜艇对象
        os[1] = new ObserverSubmarine();//为下标1 赋值一个侦察潜艇对象
        ms = new MineSubmarine[2];   //创建了一个水雷潜艇数组 开辟2块空间
        ms[0] = new MineSubmarine();//为下标0 赋值一个水雷潜艇对象
        ms[1] = new MineSubmarine();//为下标1 赋值一个水雷潜艇对象
        t= new Torpedo[2];              //创建一个鱼雷数组 开辟2块空间
        t[0] = new Torpedo(80,50); //为下标0 赋值一个鱼雷对象
        t[1] = new Torpedo(80,70); //为下标1 赋值一个鱼雷对象
        m= new Mine[2];              //创建一个水雷数组 开辟2块空间
        m[0] = new Mine(180,50);//为下标0 赋值一个水雷对象
        m[1] = new Mine(180,70);//为下标1 赋值一个水雷对象
    }

```

#### 项目问题：当前7个模板类中,存在共有属性和行为！代码冗余。

#### 解决:可以使用继承来解决!

#### 继承

- ##### 生活中的继承？

  - ##### 继承财产：钱不用自己挣,继承过来也能花。

  - ##### 继承皇位：江山不用自己打,继承过来也能坐。

  - ##### 继承工作：工作不用自己找,继承过来也能干活。

- ##### 程序中的继承指的是继承代码,代码不用自己写,继承父的也能用！

- ##### 继承适用性：当多个模板类之间存在共有的属性和行为时,并且这些模板类在概念是一种的关系。

  - ##### 父类中放：所有子类共有的属性和行为！

  - ##### 泛化：从多个模板类之间分析并提取共有属性和行为到父类中的过程称之为泛化.

  - ##### 继承的关键字:  extends         语法：子类名  extends  父类名

  - ##### 子类中放：自己特有的属性和行为！

    - ##### 父类只能访问自己的内容

    - ##### 子类不仅可以访问自己的内容,也可以访问继承得来的内容(继承过来代表自己有)

  - ##### 继承的特点：继承的单一性，继承的传递性

  - ##### 继承的缺点：耦合度比较高！(父类代码如果发生修改,直接影响所有子类 ! )

```java
class Person{//人类	----概念上的类----叫做父类！
    //数据
    String  name;
    int age;
    char sex;
    //行为
    void eat(){  }
}
class Student extends Person { //学生类 ----子类
    int stuId;//学号
    void study(){ }
}
class Teacher extends Person {//老师类
    double salary;//工资
    void teach(){  }
}
class Doctor extends Person  {//医生类
    int level;//职级
    void cut(){ }
}

```

```java
class 爷爷类{
    void 传家宝(){
        
    }
}
class 爸爸类 extends 爷爷类{
     void 传家宝(){
        
    }	
}

class 孙子类 extends 爸爸类{
     void 传家宝(){
        
    }
}
```

#### 项目中的模板优化:

##### 将当前项目中7个模板类之间存在共有的属性和行为提取到SeaObject这个父类中实现复用,7个模板类分别继承SeaObject。

```java
package cn.tedu.submarine;

/**
 * 海洋对象类：
 *          放7个模板类中共有的属性和行为
 */
public class SeaObject {
    int width;
    int height;
    int x;
    int y;
    int speed;
    
    void step(){
    }
}

```

#### Super 关键字 

> super 代表的是 父类   在哪个类中使用super 该super则表示这个类的父类!

- ##### 	super();      ----------- 调用父类的构造方法.

- #####     super.变量 ---------- 指的是父类中的全局变量!   (应用率极低)   

- #####     super.方法 ---------- 指的是父类中的某个方法!  

##### Java规定,构造方法是不可被继承！

- ##### 如果实现了继承,当子类被创建对象时,子类的构造方法中会先去调用父类的构造方法的内容,再执行自己的构造方法内容。默认的是子类构造方法调用的是父类无参的构造方法.

  - ##### 现象：在子类的构造方法中,默认有一个写法 :    super(); 表示调用的是父类无参构造方法

    ```java
    package oo.day02;
    
    /**
     * super 关键字的使用演示类：
     */
    public class SuperDemo {
        public static void main(String[] args) {
            /**
             * 如果实现了继承,当子类被创建对象时
             * 子类的构造方法中会先去调用父类的构造方法,再执行自己的构造方法内容。
             */
             Boo b = new Boo();
    
        }
    }//类的结束花括号
    class Aoo{ //父类 / 超类
        Aoo(){
            System.out.println("Aoo类的构造方法执行了...");
        }
    }
    class Boo extends Aoo{//子类 / 派生类
        Boo(){//Boo类的构造方法
            super();//默认 调用父类的无参构造方法  不写也有这行.
            System.out.println("Boo类的构造方法执行了...");
        }
    }
    
    
    ```

- ##### 如果父类添加了有参数的构造方法,而没有写无参数的构造方法,子类一旦实现继承则会报错!

  - ##### 解决需要明确在子类的构造方法中调用父类提供的有参构造方法并使用!

```java
package oo.day02;

/**
 * super 关键字的使用演示类：
 */
public class SuperDemo {
    public static void main(String[] args) {
        /**
         * 如果实现了继承,当子类被创建对象时
         * 子类的构造方法中会先去调用父类的构造方法,再执行自己的构造方法内容。
         */
        Boo b = new Boo();
        /**
         * 如果父类添加了有参数的构造方法,而没有写无参数的构造方法,子类一旦实现继承则会报错!
             解决需要明确在子类的构造方法中调用父类提供的有参构造方法并使用!
         */
    }
}//类的结束花括号
class Aoo { //父类 / 超类
    Aoo(int a){
        System.out.println("Aoo类有参构造方法");
    }
}
class Boo extends Aoo{//子类 / 派生类
    Boo(){
        super(10);
    }
}


```

##### 问题:当前侦查潜艇类,鱼雷潜艇类,水雷潜艇类中构造方法冗余重复

##### 解决:在创建子类对象时,一定会先执行父类的构造方法,那么完全可以将这3个潜艇类构造方法冗余内容提取到父类的构造方法中做,因为潜艇宽高有不同,做成形式参数,具体由调用该构造方法的子类决定宽高的数据是多少.

##### 在SeaObject类中,做一个专门为潜艇类提供的构造方法

```java
 /**
     * 此构造方法是专门为三种潜艇提供的构造方法
     * 因为三种潜艇的宽高不同,所以做成形式参数,具体的数据由使用的子类来决定.
     */
    SeaObject(int width, int height) {
        this.width = width;
        this.height = height;
        x = -width;
        y = (int) (Math.random() * (479 - height - 150) + 150);
        speed = (int) (Math.random() * (3 - 1) + 1);
    }
```

##### 具体潜艇类调用父类的构造方法:

```java
   MineSubmarine() { //水雷潜艇类构造方法
        super(63,19);
    }

   ObserverSubmarine() { //侦察潜艇类构造方法
        super(63,19);
    }

   TorpedoSubmarine() { //鱼雷潜艇类构造方法
        super(64,20);
    }
```

##### 剩下的4个类 战舰类/炸弹类/鱼雷类/水雷类 它们这些类的构造方法的赋值过程是重复的,都需要为x y w h speed来赋值，只是每个类赋值的内容不同，那么可以做成形式参数,由具体使用的类来传递即可！

```java
 /**该构造方法是专门为战舰类/炸弹类/水雷,鱼雷类提供的构造方法
     * 因为这4个类要赋值的内容不同,则做成5个形式参数的构造方法
     * 具体数据由调用的类来传递即可！
     */
    SeaObject(int width, int height, int x, int y, int speed) {
        this.width = width;
        this.height = height;
        this.x = x;
        this.y = y;
        this.speed = speed;
    }
```

##### 4个类分别去调用父类提供的构造方法。

```java
    Battleship(){//因为战舰只会存在一个对象,且一开始战舰各种数据 都是确定好的  所以做无参构造方法
        super(66,26,270,124,20);
        life = 5;
    }
--------
      //宽,高 确定   炸弹对象的xy坐标是多少,谁创建 谁负责
    Bomb(int x, int y) {
        super(9,12,x,y,3);
    }
--------
     Mine(int x, int y) {//水雷类的构造方法
        super(11,11,x,y,2);
    }
--------
     Torpedo(int x,int y){
        super(5,18,x,y,2);
    }

```

##### 构造方法强化：

```java
        //1.创建老师对象,医生对象或学生对象时,需要为依次为对象依次打点赋值比较麻烦！ 构造方法解决！
        //2.实现第1步后,发现医生类 老师类 学生类的构造方法中,存在冗余的赋值过程！ 如何解决?
```

```java
 Student(String name,int age,char sex,int stuId){ //学生类的构造方法
        super(name, age, sex);
        this.stuId = stuId;
    }
Teacher(String name,int age,char sex,double salary){//老师类的构造方法
        super(name, age, sex);
       this.salary = salary;
    }
 Doctor(String name,int age,char sex,int level){//医生类的构造方法
        super(name, age, sex);
        this.level = level;
    }

 Person(String name,int age,char sex){//人类(父类)的构造方法
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
```

##### 问题：在测试代码中,发现有三个数组,分别是老师数组,医生数组,学生数组,想要遍历并调用这三个数组中的每个对象的sayHi方法,则需要使用3个for循环才能解决。过程是冗余重复！

##### 解决：把3个数组变成一个数组来表示即可！

#### 向上造型

> 实现向上造型的语法前提条件是有继承关系！

- ##### 语法：声明父类 new 子对象的语法 就是向上造型的语法。

- ##### 父大    子小   -------因为父可以代表子！

- ##### 向上造型好处是：当一个父类有不同的子对象时,而子对象存在多个,我们可以通过一个父类型数组来管理所有的子对象,当在调用方法时,可以通过一个for循环就能执行所有子对象的方法。

```java
class Animal{ //动物类   ---父
    
}

class Tiger extends Animal{//老虎类  ----子
    
}

main{
    	 声明类型		 创建对象
    	Animal a = new Animal();//动物 是 动物  ----语义通   程序不会报错
    	Tiger t = new Tiger();	//老虎 是 老虎  ----语义通   
    	
        Animal a1 = new Tiger();//老虎 是 动物  ----语义通
    
    	Tiger t1 = new Animal();//程序报错！！ 
    	
    
}

```

##### 解决：因为项目中,数组非常多,后期处理这些数组中的对象的行为时,需要使用多个for循环来去遍历数组并调用数组中每个对象的某些行为,特别麻烦。

##### 因为三种潜艇类型的对象后续的功能是一样的,二种雷类型的对象后续的功能是一样的。所有可以划分出两个父类型数组来管理。

```java
    Battleship ship = new Battleship();
    Bomb[] bombs;
    SeaObject[] submarine;//代表三种不通的潜艇
    SeaObject[] thunder;//代表两种不同的雷
```

```java
void action() {//普通方法 用来创建各类型对象的方法
        //同步练习: 分别为上述数组创建数组对象开辟两块空间 并为对应空间赋值对象!
        bombs = new Bomb[2];//创建了一个炸弹数组 开辟2块空间
        bombs[0] = new Bomb(50, 20);//为下标0 赋值一个炸弹对象
        bombs[1] = new Bomb(50, 40);//为下标1 赋值一个炸弹对象
        submarine = new SeaObject[6];
        submarine[0] = new TorpedoSubmarine();
        submarine[1] = new TorpedoSubmarine();
        submarine[2] = new ObserverSubmarine();
        submarine[3] = new ObserverSubmarine();
        submarine[4] = new MineSubmarine();
        submarine[5] = new MineSubmarine();
        for (int i = 0; i < submarine.length; i++) {
            submarine[i].step();
        }
        thunder = new SeaObject[4];
        thunder[0] = new Torpedo(80, 50);
        thunder[1] = new Torpedo(80, 70);
        thunder[2] = new Mine(180, 50);
        thunder[3] = new Mine(180, 70);
        for (int i = 0; i < thunder.length; i++) {
            thunder[i].step();//移动
            //攻击();
        }

    }
```

##### 问题：测试类中,调用了父类型数组中每个对象的sayHi方法,打印的信息是不明确的！无法显示具体子类的某些信息。父类中提供的方法内的代码逻辑子类不适用。

#### 重写(Override)

##### 适用性：当实现继承后,子类无法复用父类中某些方法内的逻辑时,子类可以通过重写的方式,来定义自己的逻辑内容.

- ##### 简单重写:子类重写父类的那个方法,跟父类的那个方法结构完全一致即可实现重写.

- ##### 调用父执行子的现象基于:1实现了向上造型  2.实现了重写

- ##### 重写的规则 遵循两同两小一大原则:

  - ##### 两同：子类重写父类方法时,方法名和参数列表要相同

  - ##### 两小:  

    - ##### 	子类重写父类方法时,重写的方法返回的数据要等于或小于父类方法的返回值类型。

    - #####      子类重写父类方法时,重写的方法中抛出的异常要等于或小于父类方法的异常。

  - #####  一大：子类重写父类方法时,访问权限要等于或大于父类中那个方法的访问权限。

```java
   @Override
    void sayHi() {//医生类重写父类中的sayHi
        System.out.println("你好,我叫：" + name + "今年:" + age + "岁了,我的性别是:" + sex+"我的职级是:"+level);
    }
@Override
    void sayHi() {//学生类重写父类中的sayHi
        System.out.println("你好,我叫：" + name + "今年:" + age + "岁了,我的性别是:" + sex+"我的学号是:"+stuId);
    }
  @Override
    void sayHi() {//老师类重写父类中的sayHi
        System.out.println("你好,我叫：" + name + "今年:" + age + "岁了,我的性别是:" + sex+"我的工资是:"+salary);
    }
```

##### 项目中重写：

```java
  @Override
    void step() {
        System.out.println("战舰类通过键盘左右运动...");
    }
 @Override
    void step() {
        System.out.println("炸弹向下运动...");
    }
 @Override
    void step() {
        System.out.println("水雷向上运动...");
    }
 @Override
    void step() {
        System.out.println("水雷潜艇向右运动...");
    }
  @Override
    void step() {
        System.out.println("侦察潜艇向右运动...");
    }
 @Override
    void step() {
        System.out.println("鱼雷向上运动...");
    }
   @Override
    void step() {
        System.out.println("鱼雷潜艇向右运动...");
    }
```

##### 重写强化：

```java
三种情况：
    	1.Boo 子类 只想吃西餐        ------ 不需要重写
    	2.Boo 子类 只想喝果汁 		  ------ 需要重写
    	3.Boo 子类 又想吃西餐又想喝果汁------ 需要重写
    
class Aoo{ //父类
    void eat(){
          System.out.println("吃西餐");
    }
}    
class Boo extends Aoo{// 子类
     void eat(){
          super.eat();
          System.out.println("喝果汁");
    }
}
main{
    Boo b = new Boo();
    b.eat();//
}
```

#### 重载和重写的区别：

##### 重载(Overload)：发生在同类中 ,	   方法名相同,参数个数或参数类型不同

##### 重写(Override) :  发生在父子关系中, 方法名相同,参数个数或参数类型相同

```java
class Aoo{
    void show(){
        
    }
    
}
class Boo extends Aoo{
    void show(){  	 ---重写
        
    } 
}
----------------------
class Aoo{
    void show(){
        
    }
    
}
class Boo extends Aoo{
    void show(int a){ ---重载
        
    } 
}
```

#### 画窗口

- ##### 画窗口相关的代码不需要掌握。

  1. ##### Java提供了画框和底板的功能

     ```java
     import javax.swing.JFrame;//画框的功能
     import javax.swing.JPanel;//底板的功能
     ```

  2. ##### GameWorld类继承JPanel

     ```java
     public class GameWorld extends JPanel
     ```

  3. ##### 在类中自定义绘制窗口逻辑,并在main中调用

     ```java
      /**
          * 绘制窗口的方法  ---- 在main中调用
          */
         void paintWorld(){
             JFrame j = new JFrame();//创建画框对象
             this.setFocusable(true);//窗口可聚焦
             j.add(this);//画框添加底板
             j.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//窗口关闭并停止程序
             j.setSize(641+16,479+39);//窗口大小
             j.setLocationRelativeTo(null);//设置窗口居中
             j.setVisible(true);//启动窗口
         }
     ```

##### package(包)

##### 作用：避免类名冲突,同包中不允许存在同名文件。

##### 包名：纯小写,工作包规范：域名反写.项目名称.模块名称.类名

##### 类的全包名：包名.类名

```java
package day01;
class HelloWorld{ //类的全包名： day01.HelloWorld

}
```

##### import(导入)

##### 适用性：当前类需要用到某些功能时,而这些功能不再当前类的同包中,则需要通过import导入要使用的功能类的全包名即可。

##### 快捷导入功能的全包名：alt + Enter + Enter

- ##### 如果使用的类在当前类的同包下,直接访问即可！

#### 访问修饰符

> 控制代码的可见范围,目的保护程序的合法性,安全性,健壮性。

##### 迪米特原则："不要和陌生人说话",类的成员能私有尽量私有!

##### 属性的封装:属性私有化,方法公开化.  可以获取的权限,可以设置的权限

##### public  :     公开,  当前类/ 同包类 / 子类  /非同包类

##### protected:保护 , 当前类/同包类/子类 

##### 默认的(不写) :       当前类/同包类

##### private: 私有       当前类

```java
class Card{ //卡类
    private int cardId;//卡号
    private int cardPwd;//卡密
    private int balance;//账户余额
    
    public void setBalance(int money){
        if(money > 0){
            balance += money;
        }
    }
    
    public int getBalance(){ //可以供外部获取该余额的方法
        return balance;
    }
    
    public boolean checkPwd(int pwd){
        if(pwd == cardPwd){
            return true;
        }else{
            System.out.println("密码输入错误还剩...次机会");	
            return false;
        }
    }
    
}
```

##### 当前类/同包类测试:

```java
package oo.test01;

/**
 * 访问修饰符测试:
 * public   : 当前类/同包类/子类/非同包类
 * protected: 当前类/同包类/子类
 * 默认的    : 当前类/同包类
 * private  : 当前类
 */
public class Aoo {
    public int a; //公开
    protected int b;//保护
    int c;//默认
    private int d;//私有的
    void test() {
        a = 1;//当前类可见
        b = 2;//当前类可见
        c = 3;//当前类可见
        d = 4;//当前类可见
    }
}
class Boo{ //同包类
    void test(){
        Aoo aoo = new Aoo();
        aoo.a = 1;//同包类可见
        aoo.b = 2;//同包类可见
        aoo.c = 3;//同包类可见
//        aoo.d = 4;//私有成员同包类不可见
    }
}

```

##### test02

```java
package oo.test02;

import oo.test01.Aoo;
public class Coo {
    void test(){
        Aoo aoo = new Aoo();
        aoo.a = 1; //公开的非同包可访问
//        aoo.b = 2; 保护的 非同包类不可访问
//        aoo.c = 3; 默认的 非同包类不可访问
//        aoo.d = 4; 私有的 非同包类不可访问
    }
}

class Doo extends Aoo{
    void test(){
        a = 1;//非同包子类 可以访问 公开权限
        b = 2;//非同包子类 可以访问 保护权限
//        c = 3;非同包子类 不可访问 默认权限
//        d = 4;非同包子类 不可访问 私有权限
    }
}

```

#### final关键字

> ##### final代表是最终的意思

- ##### 修饰变量 :用final修饰的属性,不可二次修改,且声明时需要初始化

- ##### 修饰方法:用final修饰的方法,不能被重写   -----存在于父级代码中

- ##### 修饰类:    用final修饰的类 ,  不能被继承   ------存在功能类中

```java
package oo.day03;

import java.util.Scanner;

/**
 * final 测试使用类:
 */
public  class FinalDemo {
    public final int a = 100;//final修饰变量 需要声明时初始化

    void test() {
        System.out.println(a);
//        a = 200; final修饰的变量不可二次修改!
    }
}
final class Aoo { //被final修饰的类不能被继承
    protected final void show() {//被final修饰的方法子类无法重写

    }
}
//class Boo extends Aoo{
////    protected void show(){
////
////    }
//}
```

#### static(静态)

##### 每个学生手里拿到杯子,属于当前对象的.	-------> 实例(对象)资源

##### 饮水机不属于对象的,但可以被对象共享.    -------> 静态资源

- ##### 静态变量

  > 用static修饰的变量 称之为静态变量

  ##### 适用性:当有一份数据,多个对象都要使用时,我们就可以做成静态的变量。

  - ##### 	目的：让对象共享该资源。

  ##### 变量分类

  - ##### 实例变量:属于对象的,有多少个对象就有多少份,在堆中存储,访问则通过对象来访问.

  - ##### 静态变量:属于类的,且只有一份,被所有对象共享,在方法区中存储,访问则通过类名来访问.

    - ##### 类对应的.class字节码文件,在这个类被首次使用时,会加载到方法区中,只会被加载一次.

```java
JVM 划分三块区域:
1.栈区:放局部变量
2.堆区:放对象
3.方法区: 用来加载类.class字节码文件(类中静态资源(静态变量/方法),普通方法,构造方法)    
```

```java
package oo.day03;

/**
 * 静态变量的使用演示类:
 */
public class StaticVarDemo {
    public static void main(String[] args) {
        Boo b1 = new Boo();
        b1.show();
        Boo b2 = new Boo();
        b2.show();
        Boo b3 = new Boo();
        b3.show();
    }
}
class Boo{
    public int a;//实例变量
    public static int b;//静态变量
    Boo(){
        a++;
        b++;
    }
    public void show(){
        System.out.println("实例变量a的值是:"+a+",静态变量b的值是多少"+b);
    }
}

```

- ##### 静态方法

  > 用static修饰的方法称之为静态方法

  - ##### 静态方法适用性：存在于工具类中,代表的就是一个常用的功能,好处可以方便外部调用，不需要通过创建对象的形式,直接通过类名打点进行调用。

  - ##### 静态方法是属于类的,存储在方法区中,访问则通过类名打点访问。

  - ##### 静态方法没有this传递,所以无法直接调用类中的实例成员(实例变量,普通方法).

    ```java
    package oo.day03;
    
    /**
     * 静态方法的使用演示类：
     */
    public class StaticMethodDemo {
    
        public static void main(String[] args) {
            Coo.test02();//访问静态方法 通过类名打点调用
        }
    }
    
    class Coo {
        public int a;//实例变量
        public static int b;//静态变量
    
        void test() { //普通方法 :即可访问实例变量,又可以访问静态变量
            this.a = 10;//隐式写法的this.
            Coo.b = 20;//静态的内容 隐式写法 类名.
        }
        public static void test02() {//静态方法 ,没有隐式 this 传递
    //        this.a = 10; 无法访问实例成员(实例变量,普通方法)
    //        this.test();
    
            b = 20;//可以访问静态成员
        }
    
    }
    ```

- ##### 静态代码块

  > 用static修饰的代码块称之为静态代码块

  - ##### 静态代码块在当前类的.class字节码文件被首次加载时,会执行该类的静态代码块！(只会执行一次)

  - ##### 适用性：可以对一些静态资源在当前类不需要创建对象时进行初始化的操作.

```java
class Doo{  	
	public static int a;//静态变量
    //构造方法存在的目的是为了给实例变量初始化赋值.

    //静态代码块存在的目的是给静态变量初始化赋值.
    static {
       a = 20;
    }
}
```

##### 项目中需要用到图片资源,该资源都是静态资源,需要在静态代码块中初始化图片资源,供外部直接通过类名打点的形式直接访问图片使用.

```java
package cn.tedu.submarine;


import javax.swing.*;

/**
 * 图片资源类：
 * 存放加载项目中所需要用到的图片资源
 */
public class ImageResources {
    // ImageIcon图片类型  可以存图片资源的一种类型
    public static ImageIcon battleship;  //声明一个用来存战舰图片的 图片类型的变量
    public static ImageIcon bomb;       //声明一个用来存炸弹图片的 图片类型的变量
    public static ImageIcon gameover;   //声明一个用来存游戏结束图片的 图片类型的变量
    public static ImageIcon mine;       //声明一个用来存水雷图片的 图片类型的变量
    public static ImageIcon minesubm;   //声明一个用来存水雷潜艇图片的 图片类型的变量
    public static ImageIcon obsersubm;  //声明一个用来存侦察潜艇图片的 图片类型的变量
    public static ImageIcon sea;        //声明一个用来存海洋图背景图片的 图片类型的变量
    public static ImageIcon start;      //声明一个用来存游戏开始图片的 图片类型的变量
    public static ImageIcon torpedo;    //声明一个用来存鱼雷图片的 图片类型的变量
    public static ImageIcon torpesubm;  //声明一个用来存鱼雷潜艇图片的 图片类型的变量

    static { //静态代码块
        battleship = new ImageIcon("img/battleship.png");
        bomb = new ImageIcon("img/bomb.png");
        gameover = new ImageIcon("img/gameover.png");
        mine = new ImageIcon("img/mine.png");
        minesubm = new ImageIcon("img/minesubm.png");
        obsersubm = new ImageIcon("img/obsersubm.png");
        sea = new ImageIcon("img/sea.png");
        start = new ImageIcon("img/start.png");
        torpedo = new ImageIcon("img/torpedo.png");
        torpesubm = new ImageIcon("img/torpesubm.png");
    }

//    public static void main(String[] args) {
//        //getImageLoadStatus(); 获取图片状态  ---- 8 没问题   ---- 4有问题
//        System.out.println(battleship.getImageLoadStatus());
//        System.out.println(bomb.getImageLoadStatus());
//        System.out.println(gameover.getImageLoadStatus());
//        System.out.println(mine.getImageLoadStatus());
//        System.out.println(minesubm.getImageLoadStatus());
//        System.out.println(obsersubm.getImageLoadStatus());
//        System.out.println(sea.getImageLoadStatus());
//        System.out.println(start.getImageLoadStatus());
//        System.out.println(torpedo.getImageLoadStatus());
//        System.out.println(torpesubm.getImageLoadStatus());
//    }
}

```

#### 常量

##### 用static final修饰的量称之为常量

- ##### 常量结合了static和final的特点： 通过类名访问,声明时初始化,且不能二次修改。

- ##### 常量的适用性：当有一份数据,几乎不会发生修改,且经常使用时。 1.方便使用  2.数据稳定

- ##### 常量的命名：纯大写,多个单词之间建议下划线隔开！    

```java
    public static final int C = 300;//常量的声明语法
```

##### 项目中宽高的数据是固定的,而且多处需要使用这个宽或高的数据,所以直接将该内容做成常量。

```java
    public static final int WIDTH = 641;
    public static final int HEIGHT = 479;
```



#### 设计规则

- ##### 类的封装：将同一类别下的多个对象共有属性和行为提取(封装)到一个模板中.

- ##### 类的继承:多个模板之间存在共有的属性和行为时,且这些模板在某一个概念上能达到是一种的关系时,提取到父                   类中.

  - ##### 将子类之间共有的属性和行为提取到父类当中.

    - ##### 提取到父类中的行为,如果子类都能复用该方法逻辑,做成普通.

    - ##### 提取到父类中的行为,如果子类都不能复用该方法逻辑,做成抽象方法.

  - ##### 从软件设计角度讲,先有抽象方法,再有的抽象类.

  - ##### 从程序编码角度讲,先有抽象类,再有抽象方法.

  

#### 抽象方法

1. ##### 用abstract修饰的方法称之为抽象方法.

2. ##### 抽象方法需要存在于抽象类中.

3. ##### 抽象方法不能有方法体.

4. ##### 抽象方法必须要让子类重写!

##### 抽象方法的好处

- ##### 	1.父类中不能被子类复用的方法,子类都已经重写实现了,运行时也执行的是子类重写后那个方法了,还有必要做成抽象方法吗?

  #####    答:因为以后设计父类的人不一定是写子类的人! 在设计父类的时候,认为某个方法子类一定是需要重写,如果不做成抽象方法,那么实现子类的人很有可能忘记重写! 设计抽象方法可以约束子类必须重写!

- #####   2. 既然子类都实现了该抽象方法,那这个抽象方法还有存在的必要吗?

  #####   答:为了实现向上造型,可以通过调用父执行子.减少代码的编写.

#### 抽象类

1. ##### 用abstract修饰的类称之为抽象类.

2. ##### 抽象类是不能被创建对象!

   ```java
   //        SeaObject s = new SeaObject();   抽象类不能被实例化
           SeaObject[] ss = new SeaObject[3];//创建SeaObject类型的数组对象
   ```

3. ##### 抽象类只是普通类的基础上可以放抽象方法而已.

4. ##### 抽象类一定是需要子类来继承的,实现抽象内容.



#### 画对象

##### 简单画出一个对象,只需要两个步骤:  1.  拿到绘制的图片     2.需要对象的坐标

##### 在项目中画对象需要5步骤

1. ##### 项目中7个类型的每个对象都要图片,获取图片的行为意味着7个类都需要写获取图片的方法,每个子类都需要有获取图片的方法,则提取到父类中,则应该做成一个抽象的获取图片的方法.

   ```java
   protected abstract ImageIcon getImage();
   ```

   

2. ##### 每个对象都有两个固定状态:   活着状态  死亡的状态   -----用常量表示

   ##### 每个对象都有个当前状态   ------用变量来表示

   ```java
       public static final int LIVE = 0;//活着的状态
       public static final int DEAD = 1;//死亡的状态
       public int currentState = LIVE;//默认是活着的状态
   ```

   ##### 同时每个对象都需要被判断一下当前的状态是否是活着的,或者是死亡的,所以在父类中提供子类复用的两个普通方法.

   ```java
       public boolean isLive(){
           return currentState == LIVE;//判断当前对象的状态是否是活着的状态
       }
   
       public boolean isDead(){
           return currentState == DEAD;//判断当前对象状态是否是死亡的状态
       }
   ```

   

3. ##### 实现各个子类的重写父类中的抽象方法,getImage();

   ```java
   战舰类:
    @Override
       protected ImageIcon getImage() {//因为战舰比较特殊,如果是死亡状态游戏就结束了
           return ImageResource.battleship;//返回战舰图片
       }
   
   深水炸弹类:
    @Override
       protected ImageIcon getImage() {
           if(isLive()){
               return ImageResource.bomb;//返回深水炸弹图片
           }
           return null;//如果代码能执行到这一行则表示当前炸弹对象是死亡状态 返回null
       }
   水雷类:
    @Override
       protected ImageIcon getImage() {
           if(isLive()){//如果当前对象是活着的状态
               return ImageResource.mine;//返回水雷图片
           }
           return null;//如果代码能执行到这一行则表示当前水雷对象是死亡状态 返回null
       }
   水雷潜艇类:
    @Override
       protected ImageIcon getImage() {
           if(isLive()){//如果当前对象是活着的状态
               return ImageResource.minesubm;//返回水雷潜艇图片
           }
           return null;//如果代码能执行到这一行则表示当前水雷潜艇对象是死亡状态 返回null
       }
   侦查潜艇类:
    @Override
       protected ImageIcon getImage() {
           if(isLive()){//如果当前对象是活着的状态
               return ImageResource.obsersubm;//返回侦查潜艇图片
           }
           return null;//如果代码能执行到这一行则表示当前侦查潜艇对象是死亡状态 返回null
       }
   鱼雷类:
     @Override
       protected ImageIcon getImage() {
           if(isLive()){//如果当前对象是活着的状态
               return ImageResource.torpedo;//返回鱼雷图片
           }
           return null;//如果代码能执行到这一行则表示当前鱼雷对象是死亡状态 返回null
       }
   鱼雷潜艇类:
    @Override
       protected ImageIcon getImage() {
           if(isLive()){//如果当前对象是活着的状态
               return ImageResource.torpesubm;//返回鱼雷潜艇图片
           }
           return null;//如果代码能执行到这一行则表示当前鱼雷潜艇对象是死亡状态 返回null
       }
   
   ```

4. ##### 每个子类对象都需被绘制,那么就意味着每个对象都需要有一个绘制图片的方法,所以可以提取到父类中类定义这个子类共有的方法.

   ```java
   /**
        *为所有子类提供的绘制的行为方法,谁需要绘制,谁调用该方法
        */
       public void paintImage(Graphics g){
           ImageIcon icon = this.getImage();//获取当前调用方法对象的图片
           if(icon != null){//如果icon中存的图片对象不为空
               icon.paintIcon(null,g,this.x, this.y);//根据对象提供的坐标进行绘制
           }
   
       }
   ```

   

5. ##### 在GameWorld类的paint方法中进行调用测试

   ```java
   ship.paintImage(g);
   ```


#### 内部类

- ##### 成员内部类(应用率不高)

  - ##### 内部类对外(指的是外部类以外的类)不具备可见性

  - ##### 内部类共享外部类的属性和方法

  - ##### 内部类如果定义的变量或方法与外部类冲突时, 在内部类中,遵循就近原则。若想明确访问外部类的成员,

    - ##### 则需要外部类名.this.(访问的内容)即可.

  ```java
  class Aoo{//外部类
      
  	class Boo{//Aoo的成员内部类
          
      }    
      
  }
  ----
      package oo.day04;
  
  /**
   * 成员内部类的语法测试：
   */
  public class MemberInnerClassDemo {
      public static void main(String[] args) {
  //        Boo b1 = new Boo(); 1.内部类对外不具备可访问性
      }
  }
  
  class Aoo{//相对于Boo,Aoo是外部类
      private int a;
      void test(){
          Boo b1 = new Boo();//内部类可以在外部类中访问.
      }
      class Boo{ //内部类
          int a ;
          void test01(){
              this.a = 10;// 2.内部类共享外部类的内容
              Aoo.this.a = 20;//明确访问外部类内容的写法：外部类名.this.(属性或方法..)
  //            test();
          }
      }
  }
  ```

- ##### 匿名内部类(重点)

  > 指的就是没有名字的内部类。

  - ##### 适用性：当一个子类,仅仅只是为了重写父类中的某个方法,其它地方不需要使用这个子类,那么可以使用匿名内部类的方式来简化程序编写.  可以面向逻辑编程,忽略固定语法实现。

  ```java
  package oo.day04;
  
  /**
   * 匿名内部类的使用演示类：
   */
  public class NMInnerClassDemo {
      public static void main(String[] args) {
  //        SuperClass sc = new SubClass();
  //        sc.show();
          //匿名内部类的使用：
          //1.创建匿名内部类,该内部类是SuperClass的子类
          //2.创建该匿名内部类的对象,将对象赋值给sub
          //3.该花括号,则是匿名内部类的类体,可以该类体中实现重写,完成逻辑代码。
          SuperClass sub = new SuperClass(){ //该行创建的匿名内部类的外部类是NMInnerClassDemo
                                             //该匿名内部类的父类是SuperClass
              @Override
              public void show() {
                  System.out.println("这个通过匿名内部类的方式,创建SuperClass子类并实现重写");
              }
          };
          sub.show();//调用父执行子
      }
  }
  abstract class SuperClass{ //父类
      public abstract void show();
  }
  //目的重现实现show方法
  //代码实现：1.创建一个子类  2.实现继承   3. 重写show();
  class SubClass extends SuperClass{
      @Override
      public void show() {
          System.out.println("SubClass重写了父类的show方法...");
      }
  }
  ```

  ##### 面试题：成员内部类/匿名内部类有没有.class字节码文件？

  ##### 答：都有.class字节码文件

------

##### 目前项目需要：可以通过动态(运行时)的方式来创建对象,移动对象等。

- ##### 需要自动生成对象：三种潜艇,鱼雷,水雷

- ##### 需要自动移动对象：三种潜艇,鱼雷,水雷,炸弹

- ##### 需要手动生成对象:  炸弹

- ##### 需要手动移动对象:  战舰

##### 想实现自动发生的逻辑,需要掌握定时器的使用：

- ##### 定闹钟	

  - ##### 1. 布置闹钟任务       2.设定该闹钟任务延时多久执行    3.执行第一次后距下次执行的间隔时间

- ##### 定时器

  - ##### 1.具体执行的代码(任务)   2.从运行时延时多久执行这个代码(毫秒)  3.执行一次后距下次执行的时间(毫秒)

##### Java中提供了定时器功能以及任务模板类

1. ##### 在GameWorld类中导入该两个功能

   ```java
   import java.util.TimerTask;//任务模板类
   import java.util.Timer;//定时器类
   ```



#### 数组扩容

> 数组一旦数组对象确定,则长度固定,定容.数组是无法在自身基础上实现扩容或缩容的操作,本质上就是产生了新的数组对象。

```java
package oo.day04;

import java.util.Arrays;

/**
 * 数组拷贝方法的使用：
 * 1、Arrays.copyOf();       -----基于源数组的内容基础上进行扩容或缩容的操作.
 * 2、System.arrayCopy();    -----基于已知2个数组,例如 A数组将数据 拷贝给 B数组
 */
public class ArrayCopyDemo {
    public static void main(String[] args) {
        /**Arrays.copyOf()
         *         int[] array = {};//代表给array存储一个数组对象,但是数组对象长度为0
         *         System.out.println("扩容前数组长度:"+array.length);
         *         int a = 10;
         *         //Arrays.copyOf： 1.处理源数组对象  2.基于源数组的长度增加(扩容)或减少(缩容)
         *         array = Arrays.copyOf(array, array.length + 1);
         *         System.out.println("扩容后数组长度:"+array.length);
         *         array[array.length-1] = a;
         *         for (int i = 0; i < array.length; i++) {
         *             System.out.println(array[i]);
         *         }
         */
        /**System.arrayCopy()
         *
         */
        int[] arrA = {1, 2, 3};
        int[] arrB = {0 ,0, 0};
        /**arraycopy
         * 1.拷贝的源数组
         * 2.从源数组哪个下标进行拷贝
         * 3.拷贝的目标数组
         * 4.从目标数组哪个下标开始装
         * 5.拷贝的长度. 注意,不能超过源数组开始拷贝下标后的长度 并且 不能超过目标数组开始装的下标后的长度
         *          System.arraycopy(arrA,0,arrB,0,3);
         *         for (int i = 0; i < arrB.length; i++) {
         *             System.out.println("arrB数组元素:"+arrB[i]);
         *         }
         */
    }
}

```

#### 自动入场相关的内容

- ##### 潜艇入场

  - ##### 创建潜艇对象的方法(随机返回一个潜艇对象)	

    ```java
     /**
         * 创建潜艇对象的方法,该方法由潜艇入场的方法调用
         * 因为这个方法可以能随机返回某一种潜艇对象
         * 返回值类型写父类型
         */
        private SeaObject createSubmarine() {
            //1.产生 0 ~ 20 区间的随机整数 并接收
            //2.判断该随机数是否小于10  若满足 则返回侦察潜艇对象
            //  否则如果判断该随机数是否小于15 若满足 则返回鱼雷察潜艇对象
            //  否则 返回水雷察潜艇对象
            int type = (int) (Math.random() * 20);//1.
            if (type < 10) {//判断该随机数是否小于10
                return new ObserverSubmarine();//则返回侦察潜艇对象
            } else if (type < 15) {//判断该随机数是否小于15
                return new TorpedoSubmarine();//返回鱼雷察潜艇对象
            } else {
                return new MineSubmarine();//返回水雷潜艇对象
            }
        }
    ```

  - ##### 潜艇入场的方法

    - ##### 调用创建潜艇的方法  获取到一个潜艇对象(随机)

    - ##### 将submarine潜艇数组扩1个容量

    - ##### 将获取到的潜艇对象赋值给扩容后的数组位置

      ```java
       /**
           * 潜艇入场的方法  ------在run中调用
           */
          private void submarineEnterAction() {
              /**
               *用创建潜艇的方法  获取到一个潜艇对象(随机)1.
               *将submarine潜艇数组扩1个容量
               *将获取到的潜艇对象赋值给扩容后的数组位置
               */
              SeaObject obj = createSubmarine();//1
              submarine = Arrays.copyOf(submarine, submarine.length + 1);//2
              submarine[submarine.length - 1] = obj;//3
          }
      ```

  - ##### 在run中调用潜艇入场的方法

    ```java
     private void action() {
            Timer timer = new Timer();//创建定时器对象
            //目的：就是想要重写TimeTask抽象类中的run方法..
            TimerTask task = new TimerTask() {
                @Override
                public void run() {//在run方法中,则是需要执行的代码编写位置
                    submarineEnterAction();//调用潜艇入场的方法
                    repaint();//重新刷新绘制
                }
            };
            //schedule执行方法：1.具体任务 2.延时时间(毫秒) 3.据下次执行的间隔时间(毫秒)
            timer.schedule(task, 5000, 2000);
        }
    
    ```

- ##### 雷入场

  - ##### 	定义发射雷对象的方法 ----？

    - ###### 水雷潜艇发射水雷,鱼雷潜艇发射鱼雷,这个子类都有发射的行为,可以写在父类中定义.

      ```java
      
          /**发射雷对象的方法,由雷入场的方法进行调用
           * 如果是水雷潜艇对象调用该方法 则返回水雷对象
           * 如果是鱼雷潜艇对象调用该方法 则返回鱼雷对象
           * 如果是侦察潜艇对象调用该方法 则返回null
           */
          public SeaObject shootThunder(){
              int x = this.x +this.width;
              int y = this.y - 5;
              //判断类型的语法：instanceof
              if(this instanceof MineSubmarine){ //判断当前对象是不是 MineSubmarine类型
                  return new Mine(x,y);
              }else if(this instanceof TorpedoSubmarine){//判断当前对象是不是 TorpedoSubmarine类型
                  return new Torpedo(x,y);
              }else {
                  return null;//代码执行到这行,则表示当前调用方法的对象是侦察潜艇 返回null
              }
          }
      ```

      

  - #####    雷入场的方法 在GameWorld类的action方法上方定义一个雷入场的方法：thunderEnterAction

     ```java
    /**发射雷对象的方法,由雷入场的方法进行调用
         * 如果是水雷潜艇对象调用该方法 则返回水雷对象
         * 如果是鱼雷潜艇对象调用该方法 则返回鱼雷对象
         * 如果是侦察潜艇对象调用该方法 则返回null
         */
        public SeaObject shootThunder(){
            int x = this.x +this.width;
            int y = this.y - 5;
            //判断类型的语法：instanceof
            if(this instanceof MineSubmarine){ //判断当前对象是不是 MineSubmarine类型
                return new Mine(x,y);
            }else if(this instanceof TorpedoSubmarine){//判断当前对象是不是 TorpedoSubmarine类型
                return new Torpedo(x,y);
            }else {
                return null;//代码执行到这行,则表示当前调用方法的对象是侦察潜艇 返回null
            }
        }
    ```

    

    - ##### 循环遍历潜艇数组并调用数组中的每个对象的shootThunder方法 接收 获取一个雷对象

    - ##### 将thunder数组扩1个容量

    - ##### 将雷对象赋值给扩容后的位置

      ```java
       /**
           * 雷入场的方法  ----在run中调用
           */
          private void thunderEnterAction() {
              /**
               *1循环遍历潜艇数组并调用数组中的每个对象的shootThunder方法 接收 获取一个雷对象
               * 如果雷对象不为空,则执行2,3
               *2 将thunder数组扩1个容量
               *3将雷对象赋值给扩容后的位置
               */
              for (int i = 0; i < submarine.length; i++) {
                  SeaObject obj = submarine[i].shootThunder();
                  System.out.println(obj);
                  if (obj != null) {
                      thunder = Arrays.copyOf(thunder, thunder.length + 1);
                      thunder[thunder.length - 1] = obj;
                  }
              }
          }
      ```

      

  - ##### 在run调用雷入场的方法

    ```java
     private void action() {
            Timer timer = new Timer();//创建定时器对象
            //目的：就是想要重写TimeTask抽象类中的run方法..
            TimerTask task = new TimerTask() {
                @Override
                public void run() {//在run方法中,则是需要执行的代码编写位置
                    submarineEnterAction();//调用潜艇入场的方法
                    thunderEnterAction();//调用雷入场的方法
                    repaint();//重新刷新绘制
                }
            };
            //schedule执行方法：1.具体任务 2.延时时间(毫秒) 3.据下次执行的间隔时间(毫秒)
            timer.schedule(task, 5000, 2000);
        }
    ```

- #### 自定移动的相关实现

  - ##### 需要自动移动的对象：潜艇,雷,炸弹

    ```java
    所有的潜艇类的step方法中要改成： x += speed;
    所有的雷类的step方法中改成： y -= speed;
    Bomb类的step方法中改成: y+=speed;
    ```

  - ##### 在GameWorld类中定义一个 stepAction

    - ##### 循环遍历潜艇数组中每个对象,并调用每个对象的step方法

    - ##### 循环遍历雷数组中每个对象,并调用每个对象的step方法

    - ##### 循环遍历炸弹数组中每个对象,并调用每个对象的step方法

    ```java
      /**
         * 用来处理所有自动移动的操作  -----在run中调用
         */
        private void stepAction() {
            /**循环遍历潜艇数组中每个对象,并调用每个对象的step方法
             - 循环遍历雷数组中每个对象,并调用每个对象的step方法
             - 循环遍历炸弹数组中每个对象,并调用每个对象的step方法
             */
            for (int i = 0; i < submarine.length; i++) {
                submarine[i].step();
            }
            for (int i = 0; i < thunder.length; i++) {
                thunder[i].step();
            }
            for (int i = 0; i < bombs.length; i++) {
                bombs[i].step();
            }
        }
    ```

  - ##### 在run中调用stepAction

  ```java
  private void action() {
          Timer timer = new Timer();//创建定时器对象
          //目的：就是想要重写TimeTask抽象类中的run方法..
          TimerTask task = new TimerTask() {
              @Override
              public void run() {//在run方法中,则是需要执行的代码编写位置
                  submarineEnterAction();//调用潜艇入场的方法
                  thunderEnterAction();//调用雷入场的方法
                  stepAction();//调用自动移动的方法
                  repaint();//重新刷新绘制
              }
          };
          //schedule执行方法：1.具体任务 2.延时时间(毫秒) 3.据下次执行的间隔时间(毫秒)
          timer.schedule(task, 3000, 10);//0.01s执行一次
      }
  
  ```

  ##### 需要手动移动:战舰通过按下键盘左右键移动

  ##### 需要手动生成:炸弹通过按下键盘的空格键生成

  

  ##### 事件:	发生了一件事情											(按下键盘空格键发射深水炸弹)

  ##### 事件处理:条件达成后要做的逻辑							 (条件:按下了键盘空格键)

  ##### 事件侦听:用来检测事件处理中的条件有没有达成  (侦听:实时检测键盘有没有被按下)

- ##### Java中提供了事件功能,提供键盘侦听器功能

  ```java
  import java.awt.event.KeyEvent;//键盘事件
  import java.awt.event.KeyAdapter;//键盘侦听器
  ```

- ##### 在GameWorld类中的action方法加上键盘相关的响应代码

  ```java
   private void action() {
          //侦听用户是否按下键盘!
          //1.创建侦听器对象  2.侦听当按下键盘的方法
          KeyAdapter adapter = new KeyAdapter() {
              @Override
              public void keyPressed(KeyEvent e) {//当按下键盘的方法---在方法中写当按下后响应的逻辑
                  System.out.println("键盘被按下了!!!");
              }
          };
          addKeyListener(adapter);//将侦听器对象 添加在键盘检测当中
  
          Timer timer = new Timer();//创建定时器对象
          //目的：就是想要重写TimeTask抽象类中的run方法..
          TimerTask task = new TimerTask() {
              @Override
              public void run() {//在run方法中,则是需要执行的代码编写位置
                  submarineEnterAction();//调用潜艇入场的方法
                  thunderEnterAction();//调用雷入场的方法
                  stepAction();//调用自动移动的方法
                  repaint();//重新刷新绘制
              }
          };
          //schedule执行方法：1.具体任务 2.延时时间(毫秒) 3.据下次执行的间隔时间(毫秒)
          timer.schedule(task, 3000, 10);//0.01s执行一次
      }
  ```
  
- #### 炸弹的入场基于用户按下了键盘的空格键来触发。

  - ##### 如果判断用户是否按下了空格键

    ```java
     public void keyPressed(KeyEvent e) {//当按下键盘的方法---在方法中写当按下后响应的逻辑
    //                e.getKeyCode() 获取用户当前按下的键盘
                    if(e.getKeyCode() == KeyEvent.VK_SPACE){//获取按下的键盘码 与 KeyEvent.VK_SPACE 判等
                        System.out.println("按下了键盘的空格键！！");
                    }
                }
    ```

  - #### 深水炸弹入场实现：

    - ##### 写一个发射炸弹的方法   shootBomb

      ```java
       /**战舰类提供发射炸弹的行为方法
           *
           */
          public Bomb shootBomb(){
              return new Bomb(x,y);//返回炸弹对象  位置在战舰对象的位置
          }
      ```

    - ##### 实现炸弹入场的方法  -----在GameWorld定义 bombEnterAction 方法

      1. ##### 通过战舰对象调用shootBomb方法,接收炸弹对象

      2. ##### 为bomb数组扩1容量

      3. ##### 将炸弹对象装载到bomb数组扩容后的位置

      ```java
       /**
           * 炸弹入场的方法  -----在按下空格键的if语句中调用
           */
          private void bombEnterAction() {
              /**
               *1 通过战舰对象调用shootBomb方法,接收炸弹对象
               *2为bomb数组扩1容量
               *3将炸弹对象装载到bomb数组扩容后的位置
               */
              Bomb obj = ship.shootBomb();//1.
              bombs = Arrays.copyOf(bombs, bombs.length + 1);//2
              bombs[bombs.length - 1] = obj;//3
          }
      ```

    - ##### 在当按下键盘空格键的if语句中调用炸弹入场的方法

      ```java
      KeyAdapter adapter = new KeyAdapter() {
                  @Override
                  public void keyPressed(KeyEvent e) {//当按下键盘的方法---在方法中写当按下后响应的逻辑
      //                e.getKeyCode() 获取用户当前按下的键盘
                      if (e.getKeyCode() == KeyEvent.VK_SPACE) {//获取按下的键盘码 与 KeyEvent.VK_SPACE 判等
                          bombEnterAction();//调用炸弹入场的方法
                      }
                  }
              };
              addKeyListener(adapter);//将侦听器对象 添加在键盘检测当中
      ```

- #### 战舰的移动  当按下键盘的左键  右键 实现左右运动

  - ##### 按下键盘的左键 或 右键

    ```java
                    if(e.getKeyCode() == KeyEvent.VK_LEFT){//判断用户是否按下左键  ←
                        //调用战舰的左移方法
                    }else if(e.getKeyCode() == KeyEvent.VK_RIGHT){//判断用户是否按下右键 →
                        //调用战舰的右移方法
                    }
    ```

  - ##### 实现战舰的移动方法

    ```java
     public void moveLeft() { //左移
            x -= speed;
        }
    
        public void moveRight() {//右移
            x += speed;
        }
    ```

- #### 问题：所有的潜艇,雷,炸弹虽然移出屏幕,但实际还存在于内存中。

```java
400毫秒  -----1个潜艇对象
 1秒     ---- 2个潜艇对象  2个雷对象   ----4
 1分钟   ---- 240个对象
 10分钟  ---- 2400个对象
-------------------------------------------------------
 10毫秒  ----移动方法至少遍历2400个对象   paint方法至少也要遍历2400个对象 ------遍历4800个对象
 1秒    -----？？？？   
```

##### 内存泄漏：指的是在内存中不断产生新对象的过程。

##### 内存溢出：指的是内存中没有空间可以用。-------程序异常终止

##### GC：垃圾回收器,不定期的清理内存产生垃圾。

#### 优化越界的对象！应该把越界对象变为垃圾。

- ##### 可以优化的对象：所有潜艇对象,雷对象,炸弹对象越界则需要被优化

  - ##### 分析每个对象越界标准

    ```java
    潜艇的越界标准：this.x >= GameWorld.WIDHT;
    炸弹的越界标准：this.y >= GameWorld.HEIGHT;
    鱼雷的越界标准：this.y <= -this.height;
    水雷的越界标准：this.y <= 150- this.height;
    ```

  - ##### 几乎每个子类都需要有一个判断该类型对象的是否越界的行为,完全可以提取到父类中,定义一个判断对象是否越界的方法。因为有3个子类可以复用同一个逻辑,剩下3个子类不同,自行进行重写即可！

```java
/**判断对象是否越界的方法
     * 因为三个潜艇类越界标准是一样的,所以也可以做成普通方法让所有潜艇类复用
     *      剩下的炸弹类,鱼雷类,水雷类不适用则 自行进行重写实现！
     */
    public boolean isOutBounds(){
        return this.x >= GameWorld.WIDTH;
    }
--------------
 @Override
    public boolean isOutBounds() {//炸弹重写越界标准方法
        return this.y >= GameWorld.HEIGHT;//炸弹的越界标准
    }
---------------
    @Override
    public boolean isOutBounds() {//水雷类的重写
        return this.y <= 150 - this.height;//水雷的越界标准  ---出水平面的标准
    }
---------------
     @Override
    public boolean isOutBounds() {//鱼雷的越界方法标准重写。
        return this.y <= -this.height; //鱼雷的判断标准 ---鱼雷升到窗口上方时。
    }

```

- ##### 因为每个对象需要实时判断是否越界,则需要在GameWorld类中定义一个删除越界对象的方法

  - ##### deleteOfOutBounds(删除越界对象)

    - ##### 循环遍历潜艇数组中每个对象,并调用每个对象的isOutBounds方法, if(submarine[i].isOutBounds){  需要处理删除当前越界对象的逻辑}

    - ##### 循环遍历雷数组中每个对象,并调用每个对象的isOutBounds方法,

      #####  if(thunder[i].isOutBounds){  需要处理删除当前越界对象的逻辑}

    - ##### 循环遍历炸弹数组中每个对象,并调用每个对象的isOutBounds方法,

      #####  if(bombs[i].isOutBounds){  需要处理删除当前越界对象的逻辑}

      ##### 缩容逻辑,将当前越界对象与当前数组最后一个元素交换,然后实现缩容。
    
    ```java
    private void deleteOfOutBounds(){
            /**
             *1.循环遍历潜艇数组中每个对象,并调用每个对象的isOutBounds方法, if(submarine[i].isOutBounds)
             * {  需要处理删除当前越界对象的逻辑}
             *2.循环遍历雷数组中每个对象,并调用每个对象的isOutBounds方法,
             * if(thunder[i].isOutBounds){  需要处理删除当前越界对象的逻辑}
             *3.循环遍历炸弹数组中每个对象,并调用每个对象的isOutBounds方法,
             *if(bombs[i].isOutBounds){  需要处理删除当前越界对象的逻辑}
             * 缩容逻辑,将当前越界对象与当前数组最后一个元素交换,然后实现缩容。
             */
            for (int i = 0; i < submarine.length; i++) {
                if(submarine[i].isOutBounds()){//判断当前潜艇对象是否越界
                    submarine[i] = submarine[submarine.length-1];//将数组最后一个元素覆盖赋值给当前越界对象
                    submarine = Arrays.copyOf(submarine,submarine.length-1);//缩容
                }
            }
            for (int i = 0; i < thunder.length; i++) {
                if(thunder[i].isOutBounds()){
                    thunder[i] = thunder[thunder.length-1];
                    thunder = Arrays.copyOf(thunder,thunder.length-1);
                }
            }
            for (int i = 0; i < bombs.length; i++) {
                if(bombs[i].isOutBounds()){
                    bombs[i] = bombs[bombs.length-1];
                    bombs = Arrays.copyOf(bombs,bombs.length-1);
                }
            }
        }
    
    ```
    
    

- ##### 在run中调用deleteOfOutBounds方法

```java
 private void action() {
        //侦听用户是否按下键盘!
        //1.创建侦听器对象  2.侦听当按下键盘的方法
        KeyAdapter adapter = new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {//当按下键盘的方法---在方法中写当按下后响应的逻辑
//                e.getKeyCode() 获取用户当前按下的键盘
                if (e.getKeyCode() == KeyEvent.VK_SPACE) {//获取按下的键盘码 与 KeyEvent.VK_SPACE 判等
                    bombEnterAction();//调用炸弹入场的方法
                }
                if(e.getKeyCode() == KeyEvent.VK_LEFT){//判断用户是否按下左键  ←
                    ship.moveLeft(); //调用战舰的左移方法
                }else if(e.getKeyCode() == KeyEvent.VK_RIGHT){//判断用户是否按下右键 →
                    ship.moveRight(); //调用战舰的右移方法
                }
            }
        };
        addKeyListener(adapter);//将侦听器对象 添加在键盘检测当中
     
        Timer timer = new Timer();//创建定时器对象
        //目的：就是想要重写TimeTask抽象类中的run方法..
        TimerTask task = new TimerTask() {
            @Override
            public void run() {//在run方法中,则是需要执行的代码编写位置
                submarineEnterAction();//调用潜艇入场的方法
                thunderEnterAction();//调用雷入场的方法
                stepAction();//调用自动移动的方法
                deleteOfOutBounds();//调用删除越界对象的方法
                System.out.println("潜艇数组的长度:"+submarine.length);
                repaint();//重新刷新绘制
            }
        };
        //schedule执行方法：1.具体任务 2.延时时间(毫秒) 3.据下次执行的间隔时间(毫秒)
        timer.schedule(task, 3000, 10);//0.01s执行一次
    }
```

#### 后续项目的交互逻辑

- ##### 深水炸弹跟潜艇碰撞

  - ##### 炸弹打到水雷潜艇，加1条命,炸弹,水雷潜艇消失。

  - ##### 炸弹打到鱼雷潜艇，加40分,炸弹,鱼雷潜艇消失。

  - ##### 炸弹打到侦察潜艇，加10分,炸弹,侦察潜艇消失。

- ##### 鱼雷/水雷跟战舰碰撞，战舰扣1命,对应的雷消失。

- ### 接口

  - ##### 定义：接口是一组行为的代表,接口只关心多个类之间行为上是否达到一致。

  - ##### 适用性：如果多个类之间只是存在共有行为时(在父类中无法复用情况下),优先使用接口来代表。

  - ##### 特点：一个类,可以实现多个接口！(多实现)

  - ##### 规则：一个接口,一般里面只写一个行为！不要写大而全的接口！

  - ##### 接口是引用类型,同样有后缀.class字节码文件

  - ##### 接口语法定义：用interface关键字来定义接口

  - ##### 接口中只能放常量和抽象方法       jdk1.8后,支持放静态方法和默认方法

  - ##### 接口是需要实现类来实现接口中所有的抽象方法！

  - ##### 实现类如果想要实现接口,需要通过关键字 implements

  - ##### 实现类又想去继承父类,又想去实现接口： 先继承后实现

  - ##### 实现类若想要实现多个接口,那么逗号隔开即可！

  - ##### 实现类实现的接口如果还继承了其它接口,实现则需要一并完全实现。

  ```java
  class Aoo{ //类的定义
      
  }
  
  interface inter{//接口的定义
      
  }
  ----------------
      package oo.day05;
  
  /**
   * 接口的语法测试：
   */
  public class InterfaceDemo {
      static final int A = 1;
      public static void main(String[] args) {
          Inter1 i1 = new Aoo();//向上造型！
          i1.show();//调用父执行子...
      }
  }
  interface Inter1 {//接口的定义
      //接口中的访问修饰符默认都是public
      //常量和抽象方法
      int A = 10;//接口中默认写的就是常量  static final int A = 10;
      void show();//接口中方法默认就是抽象方法 abstract
  }
  interface Inter2{ void test1(); }
  interface Inter3{ void test2(); }
  interface Inter4 extends Inter2,Inter3{
  }
  class SuperClass{//父类
  }
  class Aoo extends SuperClass implements Inter1,Inter4{
      @Override
      public void show() {
          System.out.println("重写Inter1接口中的show方法");
      }
      @Override
      public void test1() {
      }
      @Override
      public void test2() {
      }
  }
  
  /**  关系
   *   类     与     类     继承关系  -----单继承
   *   接口   与     接口   继承关系  -----多继承
   *   接口   与     类    实现关系
   */
  
  ```

  #### 面试题：抽象类和接口的区别？

  - ##### 语法区别：

    - ##### 抽象类可以有构造方法      									|      接口没有构造方法

    - ##### 抽象类普通变量,常量，普通方法/抽象方法         |     接口只能放抽象方法   JDK1.8支持静态/默认方法

    - ##### 抽象类可以选择不同的访问修饰符                        |    接口中访问修饰符只能是public

    - ##### 类是单继承                                                              |     接口可以多继承,多实现

  - ##### 设计区别：

    - ##### 继承抽象类：当多个类之间存在共有的属性和行为,且在概念上是一种的关系,可以使用继承。

      - ##### 继承好处：因为概念一致,所以共有属性和行为 都可以达到复用。

      - ##### 继承缺点：耦合度高！牵一发而动全身.

    - ##### 实现接口：  当多个类之间存在共有的行为时,不管概念是否一致,只要行为一致,就可以用接口来代表这些类的行为.

      - ##### 接口好处:代表行为,可以实现向上造型,调用父执行子.

##### 在项目包下创建两个接口, 一个加分接口(EnemyScore)  一个加命接口(EnemyLife)

```
package cn.tedu.submarine;

/**
 * 加分的接口
 * 由侦查潜艇,鱼雷潜艇实现该接口中的加分方法
 */
public interface EnemyScore {

    int getScore();//加分的方法

}

--------------------------------

package cn.tedu.submarine;
/**
 * 加命的接口
 * 由水雷潜艇类来实现
 */
public interface EnemyLife {

    int getLife();//加命的方法
}

```

##### 分别让侦查潜艇,鱼雷潜艇实现EnemyScore接口

```
   @Override
    public int getScore() { //侦查潜艇类实现接口重写 加分的方法
        return 10;
    }
------------------------------
       @Override
    public int getScore() { //鱼雷潜艇类实现接口重写 加分的方法
        return 40;
    }
```

##### 让水雷潜艇实现EnemyLife接口

```
  @Override
    public int getLife() {
        return 1;
    }
```

- #### 多态

  > 同一类别下对象的不同实现
  >
  > 人类在睡觉的行为上实现了多态：右侧睡 ,  左侧睡, 平躺睡...

  ##### 多态：指的是一个父类在某些行为上,子类有不同的实现.

```java
人类  r1 = new 理发师();//向上造型
人类  r2 = new 医生(); //向上造型
人类  r3 = new 园丁();  //向上造型

r1.cut();//编译期期间调用父  运行期执行则理发师的cut行为
r2.cut();//编译期期间调用父  运行期执行则医生的cut行为
r3.cut();//编译期期间调用父  运行期执行则园丁的cut行为

abstract class 人类{
    abstract void cut();
}

class 理发师 extends 人类{
    void cut(){
        System.out.println("剪发");
    }
}
class 医生  extends 人类{
    void cut(){
         System.out.println("做手术");
    }
}

class 园丁  extends 人类{
     void cut(){
         System.out.println("修剪树木");
    }
}
```

##### 当一个对象被向上造型为不同的接口时,则具有不同的行为

```java
我 me = new 我();
me.授课();
me.卷();

讲师 js = new 我();
js.授课();

其它老师同事 q = new 我();
q.卷();

interface 讲师{
    授课();
}
interface 其它老师同事{
    卷();
}

class 我 implements 讲师,其它老师同事{
    授课(){ }
    卷(){ }
}
```

- ##### 向上造型 /引用类型中的自动类型转换

  - ##### 父大 子小  ----声明父  =  new 子对象();

  - ##### 能够向上造型 ： 父 new 子   ,   接口  new 实现类

- ##### 向下转型/引用类型中的强制类型转换

  - ##### 能否强转成功,要看下面两个条件,二选一：

    - ##### 条件一：要强转的引用类型变量中的对象,就是要强制转换的类型。

    - ##### 条件二：要强转的引用类型变量中的对象,实现了要转换的这个接口类型

      - ##### 子类或实现类之间是无法互相转换

      - ##### 在引用类型转换工作之前,应该使用instanceof关键字判断是否可以强制,再写强制语法.

  ```java
  main{
          Aoo a1 = new Boo();//向上造型
          if(a1 instanceof Boo){//判断a1 是否是Boo这个类型
              System.out.println("a1是Boo这个类型");
              Boo b1 = (Boo)a1;//强转成功,符合条件一 强转语法,在需要强转的变量前方小括号里加上要强转的类型
          }
          if(a1 instanceof Inter1){//判断a1 是否实现了 Inter1接口
              System.out.println("a1是实现了Inter1这个接口");
              Inter1 i1 = (Inter1)a1;//强转成功,符合条件二
          }
          if(a1 instanceof Coo){//判断a1 是否是Coo这个类型
              Coo c1 = (Coo)a1; //运行时异常: class cast Exception 类型转换异常
          }else {
              System.out.println("a1不是Coo类型");
          }
  }
  class Aoo{  
  }
  class Coo extends Aoo{ 
  }
  interface Inter1{  }
  class Boo extends Aoo implements Inter1{
  }
  ```

  ##### 碰撞逻辑的实现

  - ##### 深水炸弹跟所有潜艇碰撞   ,  鱼雷/水雷 跟战舰碰撞 . 碰撞逻辑是相通的,只是参与碰撞对象。意味着每个子类都需要有碰撞的行为,写在父类中。

    ```java
    public boolean isHit(SeaObject other){
        //this ----当前调用方法的对象
        //other ----指的是传递进入参与碰撞的对象
    }
    
    1.潜艇对象.isHit(炸弹对象) ------------this 指代的是：潜艇对象     other指的是: 炸弹对象
    2.炸弹对象.isHit(潜艇对象) ------------this 指代的是：炸弹对象     other指的是: 潜艇对象
    3.战舰对象.isHit(雷对象)   ------------this 指代的是：战舰对象     other指的是: 雷对象 
    4.雷对象.isHit(战舰对象)   ------------this 指代的是：雷对象       other指的是: 战舰对象    
    ```

  - ##### 碰撞的行为是自动发生的！

    - ##### 在GameWorld类中写一个bombBangAction方法,实现炸弹与潜艇的碰撞检测

      ```java
      /**
       * 实现炸弹与潜艇的碰撞检测
       */
      private void bombBangAction() {
          for (int i = 0; i < bombs.length; i++) {//轮数的循环
              Bomb b = bombs[i];//存储当前轮的炸弹对象
              for (int j = 0; j < submarine.length; j++) {//次数的循环
                  if (b.isHit(submarine[j])) {//拿当前轮的炸弹对象依次与潜艇数组的每个对象去检测
                      b.goDead();  //标记死亡状态
                      submarine[j].goDead();//标记死亡状态
                      
                  }
              }
          }
      }
      ```

    - ##### 在run中调用bombBangAction方法

  ##### 战舰扣减生命

  ```java
   public void subtractLife(){//减命的方法
          life--;
      }
  ```

  ##### 雷与战舰的碰撞检测,在GameWorld类中定义一个方法

  ```java
   /**
       * 雷与战舰的碰撞检测方法
       */
      private void thunderBangAction(){
          for (int i = 0; i < thunder.length; i++) {
              if(thunder[i].isHit(ship)){//如果当前雷对象与战舰对象撞上了
                  thunder[i].goDead();//将当前雷对象标记为死亡状态
                  ship.subtractLife();//战舰减命
              }
          }
      }
  ```

  ##### 在run中调用thunderBangAction.

  #### 游戏状态

  - ##### 游戏开始状态:当运行程序后,在界面呈现开始界面,当按下键盘的空格键,进入游戏运行状态

  - ##### 游戏运行状态:潜艇,炸弹,雷生成和移动的工作开始执行,碰撞检测,优化逻辑... 当战舰的命数实际为0时

  - ##### 游戏结束状态:绘制游戏结束的图片,游戏暂停.

  - ##### 开始,运行和结束状态是一个常量, 声明1个变量表示实际的当前游戏状态

    ```java
     public static final int GAME_START = 0;//开始状态
        public static final int GAME_RUNNING = 1;//运行状态
        public static final int GAME_OVER = 2;//结束状态
    
        public int currentGameStates = GAME_START;//默认就是开始状态
    ```

    ##### 不同状态下绘制的内容不同,在GameWorld类的paint方法中修改如下:

    ```java
     public void paint(Graphics g) { // g ---理解为画笔
    //        //从程序的设计角度讲,不应该在使用地方暴露细节!
    //        //绘制战舰图片在窗口中:  1.获取到战舰图片  2.根据战舰对象的坐标绘制在窗口中的位置
    //        ImageIcon icon = ImageResources.battleship;//获取战舰图片存给icon变量
    //        icon.paintIcon(null,g,270, 124);// null,g,x,y
            switch (currentGameStates){
                case GAME_START://如果当前状态是开始状态
                    ImageResources.start.paintIcon(null,g,0,0);//绘制开始图片
                    break;
                case GAME_RUNNING://如果当前状态是运行状态
                    ImageResources.sea.paintIcon(null, g, 0, 0);//绘制背景图片
                    ship.paintImage(g);
                    for (int i = 0; i < bombs.length; i++) {
                        bombs[i].paintImage(g);
                    }
                    for (int i = 0; i < submarine.length; i++) {
                        submarine[i].paintImage(g);
                    }
                    for (int i = 0; i < thunder.length; i++) {
                        thunder[i].paintImage(g);
                    }
                    g.setFont(new Font("", Font.BOLD, 20));//设置画笔加粗和大小
                    g.drawString("SCORE:" + score, 200, 50);
                    g.drawString("LIFE:" + ship.getLife(), 400, 50);
                    break;
                	case GAME_OVER://如果当前状态是结束状态
                    ImageResources.gameover.paintIcon(null,g,0,0);//绘制结束图片
                    break;
            }
        }
    ```

  - ##### 开始状态:当按下键盘的空格键切换为游戏运行状态.

  - ##### 游戏运行:当战舰命数为0时,切换游戏结束状态.

  - ##### 游戏结束:游戏结束,GameOver.

    ```java
     private void checkGameOver() {
            if (ship.getLife() <= 0) {//如果战舰命数小于或等于0
                currentGameStates = GAME_OVER;//切换游戏结束状态
            }
        }
    ```

    --------

- #### API(Application Programing Interface):功能(程序应用接口)

  - ##### 作用为了让开发者更快速的实现需求,设计API者将复杂的业务逻辑算法封装一个个的功能,对于我们使用者来讲,只需要知道这个功能怎么用即可.

  - ##### Java提供了很多功能在不同的包下:   核心语言包

    - ##### java.lang包:Java常用的核心语法包,包括一些功能: String , System,Object,包装类等....

    - ##### java.io 包: 根文件读写相关的功能.

    - ##### java.net 包: 提供网络相关的功能.

    - ##### java.util包:常用功能.

    ----------

- #### String

  - ##### String是被final修饰的,String是引用类型

  - ##### String类的内部,封装了一个不可变char数组,我们表象使用的是字符串,本质上就是存给了一个char数组,且这个数组被final修饰的,不可修改的!字符串一旦创建,不可变.

  - ##### String对象一旦被创建是不可变的!如果对String类型变量进行拼接修改,不是在原有基础上修改,而是产生了新对象.

  - ##### String不可变性:String比较常用,设计者为了优化内存,在内存中还有个字符串常量池,常量池里面则存放已经创建过的字符串对象,但是前提是以静态初始化的方式创建的. 所以当产生新的字符串对象前,会先从常量池中检索,有没有可以用的字符串,有的话就直接复用.

  ```java
  String str = "ABC";
  等价于:
  char[] chars = {'A','B','C'};
  ---
       String str1 = "ABC";
   String str2 = str1;//str1 的地址 赋值给 str2  此时str1和str2共享同一个内存地址
   str1 = str1+"DEF";//此行产生了新的String对象 地址赋值给了str1
   System.out.println(str1);//ABCDEF
   System.out.println(str2);//ABC
  ```

  ##### String创建的方式

  - ##### 静态初始化(可以复用)

    - ##### 以字符串字面量的形式创建的字符串对象  例如: String a = "123";

    - ##### 字符串常量  static final String B ="123";

    - ##### 以字符串字面的形式拼接的字符串对象   例如: String c = "1" +"23";

  - ##### 动态初始化(不可复用)

    - ##### 使用new关键字进行创建的字符串对象  例如: Stirng d = new String("123");

    - ##### 使用String类型的变量拼接而成的字符串. 例如: String d1 = "1";  String e = d1 +"23";

```java
        String str1 = "ABC";
        String str2 = "ABC";
        String str22 = "A"+"BC";
        System.out.println(str1 == str2);//引用类型的变量用双等 比较的是地址是否相同!
        System.out.println(str1 == STR);//true
        System.out.println(str1 == str22);//true
        //不可复用的形式如下:
        String str33 = "A";
        str33 += "BC";//等价于 str33 = str33 + "BC";
        String str3 = new String("ABC");
        System.out.println(str1 == str33);//false
        System.out.println(str1 == str3);//false
```

##### 面试题: String  a = new String("ABC");

##### 问:上述代码创建了几个String对象?   2个String对象    

##### 问:对象创建了几个?	创建了3个,2个String对象1个char数组对象

----------

- #### StringAPI

  - ##### String类提供一场常用的API，可以用这些功能实现例如：获取字符串长度,获取字符串对应下标具体的内容,判断内容是否包含在字符内等.....

    1. #####   length();获取字符串内容长度 

       #####   charAt(int index);通过给定下标获取对应的字符内容。

       ```java
       //        String str = "Thinking in java是一本好书";
       //        int length = str.length();//方法
       //        System.out.println(length);//21
       //        char t= str.charAt(length-1);//charAt 根据传入的下标值,返回对应下标的字符内容
       //        System.out.println(t);
               /**
                * 请编写一段程序:
                * 将str字符串对象中的"Thinking in java是一本好书"中i所存在的次数统计打印出来!
                */
               int count = 0;
               String str = "Thinking in java是一本好书";
               for (int i = 0; i < str.length(); i++) {
                    if( str.charAt(i) == 'i'){ //依次判断字符串对象中每个字符 是否等于字符 i
                       count++;//自增
                    }
               }
               System.out.println("i存在的次数为:"+ count);
       ```

    2. #####  indexOf();       从首到尾,检索传入的字符/字符串内容,检索到后立刻返回对应的下标值

       ##### lastIndexOf(); 从尾到首,检索传入的字符/字符串内容,检索到后立刻返回对应的下标值

       - ##### 如果检索的内容在字符串对象中不存在,则返回-1

       ```java
          String str = "Thinking in java是一本好书";
               int index = str.indexOf('i');
               System.out.println(index);//2
               index= str.indexOf('i',3);
               System.out.println(index);//5
               index= str.indexOf("java");
               System.out.println(index);//12
               index= str.lastIndexOf('书');
               System.out.println(index);//20
       ```

    3. ##### 字符串内容转大写,转小写,去除字符串两端空白,判断是否以..开头,以...结尾的方法.

       ```java
         String str = "Thinking in java是一本好书";
               str = str.toUpperCase();//转大写
               System.out.println(str);
               str = str.toLowerCase();//转小写
               System.out.println(str);
               str = " Tom";
               System.out.println(str);
               str = str.trim();//去除字符串两端空白行的方法
               System.out.println(str);
               boolean r = str.startsWith("T");//根据传入的内容,判断字符串对象是否以该内容开头
               System.out.println(r);
               r = str.endsWith("m");//根据传入的内容,判断字符串对象是否以该内容结尾
               System.out.println(r);
       ```

    4. ##### 截取字符串中内容的方法,可以将数值内容转换为String类型的方法

       ```java
         String mail = "bjzhangpeng@tedu.cn";
               //substring： 1.开始截取的下标 2.结束截取的下标(不包尾)
               String userName = mail.substring(0, 11);
               System.out.println(userName);
               mail = "liucs@tedu.cn";
               userName = mail.substring(0, mail.indexOf("@"));
               System.out.println(userName);
       ```

    5. ##### 提供了判断内容是否包含在字符串对象中的方法,可以将字符串对象转换为数组存储

       ```java
        String str = "OOP";
       //        boolean r = str.contains("oo");//判断传入的字符串内容,是否包含在当前字符串对象中
       //        System.out.println(r);//false   严格区分大小写,判断时同样如此。
       //        int a = 123456;
       //        String str1= String.valueOf(a);//valueOf可以将传入的类型转换为String对象
       //        System.out.println(str1);
       //        String name = "佳良";
       //        r = name.isEmpty();//判断当前字符串对象长度是否为0的方法
       //        System.out.println(r);//false
       //        name = "";
       //        System.out.println(name.isEmpty());//true
       //        name = "黄步挺";
       //        char[] chars =  name.toCharArray();//将字符串对象的内容转换为char数组来存储
       //        for (int i = 0; i < chars.length; i++) {
       //            System.out.println(chars[i]);
       //        }
       ```

##### 练习：

```java
  /**1.练习：
         *  有以下字符串内容：
         *  String str = "上海自来水来自海上";
         *  请编写一段程序,判断str对象中的内容是否是回文数！
         *          "123321"  正读倒读 都没差别
         *  思路： 依次判断数组中的元素,例如：第一个下标 与最后一个下标 元素判断是否相等 ,若相等依次继续
         *                               第二个下标 与最后二个下标 元素判断是否相等 ,若相等.......
         *  思考? 9个内容需要循环几次可以判断完。 ---->循环条件
         *    String str = "上海自来水来自海上";
         *         boolean result = true;//默认是true
         *         for (int i = 0; i < str.length() / 2; i++) {
         *             if(str.charAt(i) != str.charAt(str.length()-1 -i)){//依次判断前面的字符是否不等于后面的字符
         *                 result = false;//如果满足 则将result赋值为false 代表不是回文数
         *                 break;//退出循环
         *             }
         *         }
         *         System.out.println("是否是回文数:"+result);
         */

        /**2.练习
         *  有以下字符串内容
         *  String str = "1,永远年轻2,永远热泪盈眶3,永远在路上4,向阳而生！";
         *  请编写一段程序,将该字符串对象中,是数值的内容的数据,进行累加求和
         *  最后输出-----10
         *      String str = "1,永远年轻2,永远热泪盈眶3,永远在路上4,向阳而生！";
         *         int sum = 0;
         *         for (int i = 0; i < str.length(); i++) {
         *                  // '1' >= '0'  并且  '1' <= '9'
         *                 //  49  >= 48   并且   49 <=  57
         *             if(str.charAt(i) >= '0' && str.charAt(i) <= '9'){//循环遍历判断当前的字符是否在字符0~字符9之间
         *                  sum += str.charAt(i) - 48;//将字符 - 48 拿到对应的数值 累加给sum
         *             }
         *         }
         *         System.out.println("数值的累加和为："+ sum);
         */

        //如果遍历到的字符 >= '0'  并且 字符  <= '9'      ----本质上比较的就是字符码
        //  字符            码           如何拿到对应的     数值
        /**  0             48              字符 - 48 =    0
         *   1             49              字符 - 48 =    1
         *   2             50              字符 - 48 =    2
         *   ....
         *   9             57              字符 - 48 =    9
         */
```

##### String不可变性,一旦对String进行修改,会在内存中产生新对象.如果频繁产生新对象,对性能消耗非常大,所以一般如果需要频繁的拼接String内容,不建议使用String进行操作.

##### 如果不断产生新对象,频率特别快的情况下,内存空间极有可能被占满:出现内存溢出异常OutOfMemoryError.

#### StringBuilder

> StringBuilder类的内部,维护了一个"可变"的char数组

- ##### 增删改插,反序等

  ```java
   		String str = "好好学习";
          StringBuilder builder = new StringBuilder(str);//传入要处理的副本
          System.out.println(builder);
          //append:追加 ,在当前的字符串内容后方
          builder.append(",为了找份好工作!");
          System.out.println(builder);
          //replace:替换, 1.开始替换的下标  2.结束替换的下标(不包尾)  3.替换的内容
          builder.replace(5,builder.indexOf("!"),"为了改变世界");
          System.out.println(builder);
          //delete: 删除, 1.开始删除的下标 2.结束删除的下标
          builder.delete(builder.indexOf(","),builder.indexOf("!"));
          System.out.println(builder);
          //insert:插入, 1.开始插入的下标 2.插入的内容
          builder.insert(0,"加油,");
          System.out.println(builder);
          builder.reverse();//反序
          System.out.println(builder);
          str= builder.toString();//将StringBuilder转化为String类型
        System.out.println(str);
  ```
  

#### 正则表达式

##### 定义：用来约束用户在输入数据时的合法性,判断是否与设定的格式匹配！

##### 基本表达式

- ##### []  表示一个字符

- ##### [a,b,c]  表示可以写a或b或c 其中一个字符

- ##### [^a,b,c] 表示除了a 或 b 或 c 的任意一个字符

- ##### [a-z]      表示可以写26个小写字母中任意一个字母

- ##### [a-zA-Z0-9]  表示可以写26个小写或大写字母或0-9的数字中任意一个字母

  ```java
  [a-z&&[^b,c]] 表示可以写26个小写字母中除了b,c之外的任意一个字母
  ```

##### 预定字符集

- ##### .  表示可以写任意一个字符

- ##### \d 表示可以写任意一个0-9的数字字符

- ##### \w 表示可以写26个小写字母中任意一个字母

- ##### \s 表示可以写一个空白字符

- ##### \D 表示不能写0-9的数字字符

- ##### \W表示可以不能写字母字符

- ##### \S 表示不能写空白字符

#### 数量

```java
?	表示可以写0~1个字符
    例如：[abc]?  表示可以写0个或1个 a或b或c的字符
+   表示至少写1个字符 没有上限
    例如：[abc]+  表示可以写abc中的内容至少1个 没有上限
    
*   表示没有次数的限制 ,任意次..
    
----------------------------------
限制次数
[abc]{3} 表示只能出现3个对应的字符
    
[abc]{3,5} 表示至少写3个,最多写5个    

[abc]{3,}  表示至少写3个 没有上限     
```

#### 分组

```java
(abc){3}  视为abc为1组 至少也只能出现3次
(abc|def){3}   视为abc 或 def是一组 , 至少也只能出现3次
```



```java
package regexdemo;

import java.util.Scanner;

/**
 * 正则表达式的使用演示类：
 */
public class RegexDemo {
    public static void main(String[] args) {
//        String mail = "bjzhangpeng_@tedu.cn";//邮箱
//        String mailRegex ="[a-zA-Z0-9_]+@[a-zA-Z0-9]+(\\.[a-zA-Z]+)+";
//        if( mail.matches(mailRegex)){//判断邮箱的内容是否与正则格式内容匹配
//            System.out.println("邮箱格式正确");
//        }else {
//            System.out.println("格式错误!请注意修改!");
//        }
//        //身份证号码的正则                或
//        /**         身份证号码位数  15 位 |  18位
//         * 123456789012345        15位
//         * 123456789012345678     18位
//         * 12345678901234567x     前17位数字18位x
//         * 12345678901234567X     前17位数字18位X
//         *  \d{15}      -----15位数字
//         *  \d{17}[\dXx] ----前面是17位的数字,第18位可以是数字或x或X字母
//         *  完整格式: \d{15}|\d{17}[\dXx]
//         */
//        Scanner s = new Scanner(System.in);
//        String number = s.next();//next接受用户输入的字符串内容
//        String regex = "\\d{15}|\\d{17}[\\dXx]";
//        if(number.matches(regex)){
//            System.out.println("输入的身份证号码格式正确!");
//        }else {
//            System.out.println("输入的身份证号码有误!");
//        }
        /**座机号码正则格式:
         *      1234567     7位
         *      12345678    8位
         *  010-  1234567     3位区号-7位电话号码
         *  010-  12345678    3位区号-8位电话号码
         *  0101- 1234567    4位区号-7位电话号码
         *  0101- 12345678   4位区号-8位电话号码
         *  (010)  1234567    (3位区号)7位电话号码
         *  (010)  12345678   (3位区号)8位电话号码
         *  (0101) 1234567   (4位区号)7位电话号码
         *  (0101) 12345678   (4位区号)8位电话号码
         *  \d{7,8}     ---7或8位数字
         *  第一种区号:  \d{3,4}-
         *  第二种区号:  (\d{3,4})
         *  完全的格式:   (\d{3,4}- | (\d{3,4}))?\d{7,8}
         */
        Scanner s = new Scanner(System.in);
        String number = s.next();//next接受用户输入的字符串内容
        String regex = "(\\d{3,4}-|\\(\\d{3,4}\\))?\\d{7,8}";
        if(number.matches(regex)){
            System.out.println("座机号码格式正确");
        }else {
            System.out.println("格式错误!");
        }
    }
}

```

##### StringAPI支持正则的使用

```java
   //split();分割的方法 可以根据传入的正则内容,来匹配当做分割点,将分割的内容以数组形式返回
        String str = "abc123def456ghi";
        String[] strArr= str.split("[0-9]+");
//        System.out.println(strArr.length);
        for (int i = 0; i < strArr.length; i++) {
//            System.out.println(strArr[i]);
        }
        String userName = "username=123=password=456";
        strArr = userName.split("=");
        for (int i = 0; i < strArr.length; i++) {
            System.out.println(strArr[i]);
        }
-----------
         String message = "wr!你这个sb,tmd行不行!";
        String regex = "(wr|sb|tmd)"; //敏感词汇..
        //replaceAll:支持正则  1.正则格式   2.替换的内容
        message = message.replaceAll(regex,"***");
        System.out.println(message);


        String str = "abc123def123ghi123";
        //replace :替换 不支持正则  1.匹配的具体内容  2.替换的内容
        str = str.replace("123","NUMBER");
        System.out.println(str);

```

### Object

##### Object类是Java中所有类的父类,也称之为顶级父类!

##### 我们创建的类,都直接或简介继承Object类.

##### 在设计Java这个语言最初,Object类提供了最基础的结构支撑.

------

- #### toString();
  - ##### 当需要打印自定义类型对象的一些信息时,我们可以通过重写toString()方法,会自动帮我们生成对应这个类中数据的打印内容。 

  - ##### Java中提供大部分的类基本上都实现重写了toString方法

    ```java
    		 Point p1 = new Point(1,2);
    //        System.out.println("x值为:"+ p1.getX() +" y值为:"+p1.getY());
    //        Point p2 = new Point(5,6);
    //        System.out.println("x值为:"+ p2.getX() +" y值为:"+p2.getY());
    //        //p3 ... p4 ... p5 .....
    
            //目的：希望以后打印对象的信息更加方便
            //输出p1对象是一个 类的全包名@内存地址的信息。
            //只要打印引用类型的变量,默认就是在调用toString方法
            //希望：打印对象时,是将对象的信息显示出来
            System.out.println(p1);
            int[] arr = {10,20,30};
            System.out.println(Arrays.toString(arr));
            String str ="abcdefghi";
            System.out.println(str.toString());
    ```

  ```java
  package objectdemo;
  /**
   *  自定义类
   */
  public class Point {
      private int x;
      private int y;
  
      public Point(int x, int y) {
          this.x = x;
          this.y = y;
      }
  
      public int getX() {
          return x;
      }
  
      public void setX(int x) {
          this.x = x;
      }
  
      public int getY() {
          return y;
      }
  
      public void setY(int y) {
          this.y = y;
      }
  
      @Override
      public String toString() {
  
          return "Point{" + "x=" + x + ", y=" + y + '}';
  
      }
  }
  
  ```

- #### equals();
  - ##### 当需要判断引用类型中的内容是否相等时,要使用equals方法实现,如果是自定义类型则需要重写.

  ```java
    Point p1 = new Point(1,2);
          Point p2 = new Point(1,2);
          System.out.println(p1 == p2);//false  判断的是内存地址是否相同
          //目的：希望判断p1 对象中的xy 与p2 对象中的xy是否相等
          System.out.println(p1.equals(p2));//ture用于比较引用类型对象中的数据是否相等。
  
          
          String str1 = "ABC";
          String str2 = new String("ABC");
          System.out.println(str1);
          System.out.println(str2);
          System.out.println(str1 == str2);//比较的是地址相等
          System.out.println(str1.equals(str2));//比较的是内容是否相等
  ```

#### 面试题：

- ##### 	==和equals的区别？

  - #####  ==  是关系运算符

    - ##### ==作用

      - ##### 在基本数据类型的变量中使用==,判断的则是变量中的数据是否相等

      - ##### 在引用数据类型的变量中使用==,判断的则是变量中的地址是否相等

  - ##### equals()是方法

    - ##### Java的Object类中提供equals方法,Java的类一般都重写实现了equals方法

    - ##### 如果有自定义类需要判断该类型的对象之间的内容是否相等时,则需要在该类中重写equals方法,同时比较hashCode方法。
    
    

### 设计模式

##### 遵循面向对象开发设计的原则,市面有23种设计模式,解决的是代码上不同情况下设计上的问题.

##### 设计模式是软件设计中,总结出来的一套经验,设计模式一般应用在系统层,架构层代码.

##### 单例设计模式

##### 适用性:在程序中的实现中,往往有一些工具类会被频繁使用,如果任意位置使用都需要创建对象,那么对内存的消耗还是非常大的.

----

- ##### 饿汉式:不管外部有没有调用,提前先把对象创建好,等着被用.

  ```java
  package singletondemo;
  
  /**
   *饿汉式单例的使用演示类:
   */
  public class HungrySingleton {
      public static void main(String[] args) {
  //        HungrySingletonDemo h = new HungrySingletonDemo();
  //        h.工具();
          HungrySingletonDemo hungry1 = HungrySingletonDemo.getInstance();
          HungrySingletonDemo hungry2 = HungrySingletonDemo.getInstance();
          System.out.println(hungry1 == hungry2);
          HungrySingletonDemo.getInstance().工具();
      }
  }
  /**
   * 饿汉式单例实现:
   * 目的:不做静态工具方法,不希望外部创建对象,对外提供全局唯一的访问点
   * 1.私有化构造方法,防止外部创建对象.
   * 2.在类中给自己创建对象.
   * 3.对外提供用户获取当前类对象的静态方法.
   */
  class HungrySingletonDemo{
      private HungrySingletonDemo(){}//私有构造
      private static HungrySingletonDemo hungry = new HungrySingletonDemo();//创建对象
      public static HungrySingletonDemo getInstance(){//对外提供获取类实例的方法
          return hungry;//返回实例对象复用.
      }
      public void 工具(){
          System.out.println("工具方法执行了...");
      }
  }
  ```

- ##### 懒汉式:在首次被使用时,才会去创建对象.

##### 优点:避免内存浪费,不提前创建对象

##### 缺点:存在线程安全的问题(第二阶段的内容)

```java
package singletondemo;

/**
 * 懒汉式单例实现演示:
 */
public class LazySingleton {
    public static void main(String[] args) {
        LazySingletonDemo.getInstance().工具();
    }
}

/**
 * 懒汉式实现:
 * 目的:不做静态工具方法,不希望外部创建对象,对外提供全局唯一的访问点
 * 1.私有化构造方法
 * 2.声明一个静态的当前类类型的变量用于存储该类对象
 * 3.对外提供一个全局的访问点来使用类的工具
 */
class LazySingletonDemo {
    private LazySingletonDemo() {
    } //1.
    private static LazySingletonDemo lazy;//2.
    public static LazySingletonDemo getInstance() { //3.
        if (lazy == null) {//如果lazy == null 说明第一次被使用
            lazy = new LazySingletonDemo();//赋值进去对象
        }
        return lazy;//返回对象
    }
    public void 工具() {
        System.out.println("一个工具执行了...");
    }
}

```

-----

### 包装类

##### Java这款是面向对象的,为了能够让基本数据类型也能参与到面向对象的开发中,Java设计了8中基本数据类型对应的包装类类型.

##### 目的: 可以让值以对象的形式存在.

##### Java8种基本数据类型: byte  --- short ---int ----long ---  float --- double     (char ,boolean)

##### 整数和小数的包装类使用:

- ##### 如何将数值转换为包装类对象的形式保存

  ```java
  package wrapdemo;
  
  /**
   * 包装类:
   */
  public class WarpClassDemo {
      public static void main(String[] args) {
          /** 基本数据类型          包装类类型
           *  byte                Byte
           *  short               Short
           *  int                 Integer
           *  long                Long
           *  float               Float
           *  double              Double
           *  char                Character
           *  boolean             Boolean
           */
          //将基本数据类型转换为包装类类型
          int number = 100;
  //        Integer i1    new Integer(number);
  //        Integer i2 = new Integer(number);
  //        System.out.println(i1 == i2);//false
          Integer i1 = Integer.valueOf(127);//Integer提供的静态valueOf 有缓存机制 1个字节的内容
          Integer i2 = Integer.valueOf(127);//Integer提供的静态valueOf 有缓存机制 1个字节的内容
          System.out.println(i1);//100  重写了toString 方法
          System.out.println(i2);//
          System.out.println(i1 == i2);//true
          System.out.println(i1.equals(i2));//true
          Integer i3= Integer.valueOf("123");//支持传入String内容,但是String内容必须是数值才行
          System.out.println(i3);
          int n1 = Integer.parseInt("100");//将传入的字符串转换为具体数值类型
          System.out.println(n1);
  
          double d = 3.14;
          Double d1 = Double.valueOf(d);//将传入的基本数据类型double转换为包装类Double存储
          Double d2 = Double.valueOf(d);
          System.out.println(d1 == d2);//false
          System.out.println(d1.equals(d2));//true
          double n2 = Double.parseDouble("100.11");
          System.out.println(n2);//100.11
  
          //将包装类类型转换为基本数据类型
          
      }
  }
  
  ```

- ##### 如果将包装类对象转换为对应的数值存在

```java
 //将包装类类型转换为基本数据类型
        Integer i1 = Integer.valueOf(100);
        int n1 = i1.intValue();
        System.out.println(n1);

        Double d1 = Double.valueOf(3.14);
        double n2= d1.doubleValue();
        System.out.println(n2);

        System.out.println(Integer.MAX_VALUE);//获取int最大值
        System.out.println(Integer.MIN_VALUE);//获取int最小值

        int i = 255;
        System.out.println(Integer.toBinaryString(i));//将传入的10进制转换为2进制
        System.out.println(Integer.toOctalString(i));//将传入的10进制转换为8进制
        System.out.println(Integer.toHexString(i));//将传入的10进制转换为16进制
```

- #### 自动拆装箱

  - ##### Jdk1.5版本后,推出新特性,自动拆装箱，编译器遇到基本数据类型与对应包装类类型互相赋值时,会自动帮我们完成转换的工作,这个特性只是编译器认可,实际上并不存在直接互相赋值的操作。

  - ##### 装箱:指的是将基本数据类型 赋值 给 包装类 类型

  - ##### 拆箱:将包装类 类型 赋值 给 基本数据类型

    ```java
       //自动拆装箱
            //装箱:指的是将基本数据类型 赋值 给 包装类 类型
            /** Integer i1 = 100;
             * 实际上:   Integer i1 = Integer.valueOf(100);
             */
            Integer i1 = 100;
            System.out.println(i1);
    
    
            //拆箱:将包装类 类型 赋值 给 基本数据类型
            /** int i2 = i1;
             *  实际上: int i2  = i1.intValue();
             */
            int i2 = i1;
            System.out.println(i2);
    ```

  ##### 面试题：什么是拆箱?什么是装箱？拆装箱的过程是？

- ##### 装箱：指的是将基本数据类型 赋值 给 包装类 类型

  - ##### 装箱的过程：调用对应包装类.valueOf()方法来实现的.

- ##### 拆箱：将包装类 类型 赋值 给 基本数据类型

  - ##### 拆箱的过程:  调用对应包装类对象.xxValue()方法实现.





























FOUNDATION03